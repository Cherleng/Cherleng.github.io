<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Backtrack 回溯算法</title>
    <url>/2022/07/19/2022-05-14-backtrack/</url>
    <content><![CDATA[<h4 id="引言">1.引言</h4>
<blockquote>
<p>黄色的树林里分出两条路，可惜我不能同时去涉足,我选择了人迹稀少的一条，从此决定了我一生的道路</p>
</blockquote>
<h4 id="什么是回溯算法">2.什么是回溯算法？</h4>
<p>Backtrack算法，中译回溯算法，是一个非常实用的一个算法，如果用一个谚语来形容回溯算法，我愿意称之为“不撞南墙不回头”的一种算法。</p>
<p>为什么这么说呢？因为回溯算法实质上就是一种不断尝试，通过不断的“试错”不断更改信息的一种算法。</p>
<p>“不撞南墙”说明了当回溯算法不遇到错误的时候，“不回头”就是不返回上一步重新尝试。</p>
<p>从引言的那首罗伯特.弗罗斯特的诗里，“可惜我不能同时去涉足”，可是对于回溯算法来说不是这样的，回溯算法看到路走错了就不会继续走了，它会折返到最近的一个分岔口，重新选择一条道路行走。</p>
<figure>
<embed src="https://tse1-mm.cn.bing.net/th/id/R-C.91867e276501f596a4802b67aea756f6?rik=T2H1qdJZGAQe7g&amp;riu=http%3a%2f%2fimg95.699pic.com%2fphoto%2f50123%2f6755.jpg_wh300.jpg!%2ffh%2f300%2fquality%2f90&amp;ehk=6ZJzrS%2bT3A%2fCApII9W0nWQRrSgaCGaU1C3o6wI7aRLs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&amp;sres=1&amp;sresct=1"><figcaption>分岔的道路</figcaption>
</figure>
<p>回溯算法可以用来解数独，进行排列组合，解决N皇后等问题</p>
<h4 id="回溯算法的实现">3.回溯算法的实现</h4>
<p>让我们来看一看<a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a> 这道题</p>
<p>这道题要求我们从board里面查找某一个单词（例如：ABCDE)，如果查找到单词，我们就返回True，否则返回False。</p>
<figure>
<img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="单词搜索"><figcaption>单词搜索</figcaption>
</figure>
<p>如上所示，黄色的路径就代表我们成功找到了“ABCDE”这个连续的单词。我们可以从上、下、左、右四个方向进行单词查找。</p>
<p>这里有一点需要注意，单词并不需要第一行第一列的数字来开始，我们可以从任何点上开始单词。</p>
<h5 id="回溯算法的基本思路">回溯算法的基本思路</h5>
<p>1.确定Base case，即考虑一些越界情况，结果实现的情况。</p>
<p>2.在选择列表中进行选择</p>
<p>3.迭代下一个情况</p>
<p>4.撤销选择</p>
<p>这个回溯算法可以如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">x,y,index</span>)</span><br></pre></td></tr></table></figure>
<pre><code>  File &quot;C:\Users\86157\AppData\Local\Temp/ipykernel_7228/2593934997.py&quot;, line 1
    def backtrack(x,y,index)
                            ^
SyntaxError: invalid syntax</code></pre>
<p>x,y就是我们传进去的board的行数和列数，index为单词的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,index</span>):</span><br><span class="line">            <span class="comment">#base case</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=row <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> y&gt;=col: 、</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[x][y]!=word[index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> index ==<span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#做选择</span></span><br><span class="line"></span><br><span class="line">            board[x][y] = <span class="string">&#x27;#&#x27;</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">#进行迭代</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>]]:</span><br><span class="line">                next_x = x+i[<span class="number">0</span>]</span><br><span class="line">                next_y = y+i[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> dfs(next_x,next_y,index+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">            <span class="comment">#撤销选择</span></span><br><span class="line">            </span><br><span class="line">            board[x][y] = word[index]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">#开始点，可以从任一行任一列开始</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> dfs(i,j,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如上，按照思路，第一步：确立Base case，当索引为index的单词字符刚刚和board的x行y列的字符相同时，继续走下去，如果不是，则return，程序返回上一步（即返回上一次for循环，进行下一个循环），如果继续走下去，就再次执行刚刚的内容，如此循环，直至我们可以找到一个序列和给出的单词一致，即index的长度达到了单词的长度。</p>
<p>让我们来看下一道一个比较简单的题目， <a href="https://leetcode.cn/problems/permutations/">全排列</a></p>
<p>输入：nums = [1,2,3]</p>
<p>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums): <span class="comment">#base case</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                track.append(nums[i]) <span class="comment">#选择</span></span><br><span class="line">                backtrack() <span class="comment">#迭代</span></span><br><span class="line">                track.pop()<span class="comment">#撤销选择</span></span><br><span class="line">                </span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>还是惯常的思路，确立一个Base case,然后进行选择，进行迭代，撤销选择。</p>
<p>其实从回溯算法里面，我们也能发现一件事，那就是所谓“智能”的计算机，实际上是因为计算机拥有巨大的“计算能力&quot;，它能不厌其烦的进行大量的数据处理，并从这些数据中根据我们所确立的“basecase”进行选择。</p>
<p>如果你跟一个不知道计算机怎么运行的人演示这个全排列算法（如果你去演示一个N皇后，解数独的例子可能更好），他们会纠结于为什么你跟电脑说：“给我一个数组[1,2,3]的全排列输出。”电脑就会如实的做到，电脑他难道是因为知道全排列的含义而去思考吗？实际上是你给他一个指令，让他去遍历这些数组组成的所有有用序列，然后返回而已。</p>
<p>不过，这样也可以说明，电脑是可以拥有“学习能力”的，比如你给计算机一百万个数据，让他去处理这之间的关系（而不需要你告诉它关系是什么），然后你再丢给它一个不是数据里数字，他能返回给你一个“最接近结果”的一个值，当然，这就是另一种事情了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-SVD分解算法的物理意义</title>
    <url>/2022/07/19/svd%20linear/</url>
    <content><![CDATA[<p>奇异值分解（Singular Value Decomposition），以下简称SVD。</p>
<p>奇异值分解算法是一种在机器学习中经常使用到的一个算法，SVD主要用于数据压缩和数据降维，在图像压缩、推荐系统有着极其重要的作用，</p>
<p>本文将着重理解SVD分解算法的物理意义以及我们将用Python代码将这个过程可视化，数学推导将不是本文的重点，将在它文展示。</p>
<h4 id="一.svd分解介绍">一.SVD分解介绍</h4>
<p>任何一个形状的矩阵（图像）都可以转化从先旋转、再延伸、再旋转的形式。</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-e6b7d1aa8b6e302c1973d44d45d7f540_720w.jpg" alt="svd1"><figcaption>svd1</figcaption>
</figure>
<h4 id="公式如下">公式如下</h4>
<figure>
<img src="https://pic3.zhimg.com/80/v2-a71a3b4be58eaea23992595d495c55ce_720w.jpg" alt="svd2"><figcaption>svd2</figcaption>
</figure>
<p>SVD分解就是将一个矩阵转变为这三个矩阵的表达形式，同时，这三个矩阵分别代表一个旋转、一个伸缩、一个旋转。</p>
<figure>
<img src="https://pic2.zhimg.com/80/v2-afcc2be24efd8e722cbcf14aef0aff1d_720w.jpg" alt="img"><figcaption>img</figcaption>
</figure>
<h4 id="为什么呢">为什么呢？</h4>
<p>提出问题就解决了一半的问题。为什么一个矩阵可以转变为一个旋转矩阵、一个伸缩矩阵、一个旋转矩阵相乘呢？</p>
<p>让我们来看一个简单的例子</p>
<p><img src="https://s1.328888.xyz/2022/05/15/qmgP7.png" alt="img1"> <img src="https://s1.328888.xyz/2022/05/15/qmGKM.png" alt="img2"></p>
<p>Unit circle 要怎么转换才能转换成为下图中的A的形式呢？（这里要注意点的颜色！）</p>
<p>首先，我们先让Unit circle逆时针旋转135度。</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmyl2.png" alt="img3"><figcaption>img3</figcaption>
</figure>
<p>再让旋转后的图像在x轴上伸长6.70820393249937倍（为什么是这个倍数，先不用纠结，这是奇异值分解以后的一个奇异值数），在y轴上伸长2.2360679774997894倍</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmJhX.png" alt="img4"><figcaption>img4</figcaption>
</figure>
<p>然后我们再让图像旋转一次，即可得到和A同等的一个图像. U sigma Vt</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmLYZ.png" alt="img10"><figcaption>img10</figcaption>
</figure>
<p>这样，原图到A的过程就可以转变为将原图先进行一个旋转、再进行一个伸缩、再进行一个旋转。</p>
<p>我们知道，任何的图像的变化都可以用线性代数里的一个矩阵来表示。</p>
<p>实际上，从原图到A的一个变换矩阵就是</p>
<p><span class="math display">\[
A =  \left|\begin{matrix}
    3 &amp; 0  \\
    4 &amp; 5 
   \end{matrix} \right|
 \]</span></p>
<p>我们将其拆解以后，第一个转换图像对应的旋转是逆时针旋转135度，我们可以将第一个旋转用矩阵表示为</p>
<p><span class="math display">\[
  V=\left|\begin{matrix}
    -0.71 &amp; -0.71  \\
    -0.71 &amp; 0.71 
   \end{matrix} \right|
 \]</span></p>
<p>然后进行左乘一个伸缩矩阵（注意里面的数字和上面那个伸缩大小之间）</p>
<p><span class="math display">\[
  \Sigma = \left|\begin{matrix}
    6.71 &amp; 0  \\
    0 &amp; 2.24 
   \end{matrix} \right|
 \]</span></p>
<p>然后最后再左乘一个旋转矩阵</p>
<p><span class="math display">\[
  U = \left|\begin{matrix}
    -0.32 &amp; -0.95  \\
    -0.95 &amp; 0.32 
   \end{matrix} \right|
 \]</span></p>
<p>我们用Python中的Nupmy来协助我们计算一下这三个矩阵相乘后是否等于A</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">V =np.array( [[-<span class="number">0.71</span> ,-<span class="number">0.71</span>],</span><br><span class="line"> [-<span class="number">0.71</span> , <span class="number">0.71</span>]])</span><br><span class="line"></span><br><span class="line">sigma = np.array([[<span class="number">6.71</span> ,<span class="number">0.</span>  ],</span><br><span class="line"> [<span class="number">0.</span>  , <span class="number">2.24</span>]])</span><br><span class="line"></span><br><span class="line">U = np.array([[-<span class="number">0.32</span> ,-<span class="number">0.95</span>],</span><br><span class="line"> [-<span class="number">0.95</span>  ,<span class="number">0.32</span>]])</span><br><span class="line"></span><br><span class="line">res1 = np.matmul(U, sigma)</span><br><span class="line">res1</span><br><span class="line">res2 = np.matmul(res1,V)</span><br><span class="line">res2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>array([[3.035392, 0.013632],
       [4.016967, 5.034823]])</code></pre>
<p>我们看到矩阵相乘后生成了一个新的矩阵，而这个矩阵正是和A矩阵极其相近的一个矩阵（计算机已经认为一致）</p>
<p><span class="math display">\[
  res2 = \left|\begin{matrix}
    3.035392 &amp; 0.013632  \\
    4.016967 &amp; 5.034823 
   \end{matrix} \right|
 \]</span></p>
<p><span class="math display">\[
 A =  \left|\begin{matrix}
    3 &amp; 0  \\
    4 &amp; 5 
   \end{matrix} \right|
 \]</span></p>
<p>现在我们已经可以将一个复杂的变化（或者称之为一个复杂的变化<strong><em>矩阵</em></strong>）转变为三个简易的变化（或者称之为三个简易的变化<strong><em>矩阵</em></strong>）相乘（一个旋转、一个伸缩、一个旋转），然而事实上，<strong><em>任何一个复杂的变化都可以转变为这种分解的形式</em></strong>（在这里我们用二维矩阵来表示，为的是得到一个可视化的变化）我们称之为<strong><em>SVD奇异值分解</em></strong>。</p>
<figure>
<img src="https://pic3.zhimg.com/v2-ecca2d8bad88b73764f9af8def24c158_1440w.jpg?source=172ae18b" alt="img7"><figcaption>img7</figcaption>
</figure>
<p>你也看到了，<span class="math inline">\(\Sigma\)</span>是一个特殊的对角矩阵，而且通过刚刚可视化的转化，你知道<span class="math inline">\(\Sigma\)</span>内对角线上面的数字代表了对矩阵的变化大小程度（对拉伸变化的大小程度）也就是说<span class="math inline">\(\Sigma\)</span>内对角元素更像是代表了一种权重，比如我们将x轴拉伸为原来的6.71倍，这个变化看起来相较于将y轴变为原来的2.24倍大一点，说明我们在x轴上面进行的操作特征更接近于与原矩阵进行的操作，实际上<span class="math inline">\(\Sigma\)</span>内对角线的元素从大到小排列，我们通常只需要取出前面的几个特征值就能很好的将原图像的图像表示出来，这同时也与图像压缩相关，因为计算机内的图像实际上是数以百万计的矩阵像素形式。</p>
<figure>
<img src="https://pic3.zhimg.com/80/v2-4437f7678e8479bbc37fd965839259d2_720w.jpg" alt="img8"><figcaption>img8</figcaption>
</figure>
<p>由于<span class="math inline">\(\Sigma\)</span>是一个对角矩阵，即对角线上面存在元素，而其他位置的元素为0，根据矩阵相乘的原理，我们可以将<span class="math inline">\(\Sigma\)</span>内的对角元素提取出来，这个公式就转换成了</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-90a904448099ee0f3158bfa045012bb8_720w.jpg" alt="img5"><figcaption>img5</figcaption>
</figure>
<p>其中<span class="math inline">\(\sigma1\)</span>代表<span class="math inline">\(\Sigma\)</span>中的第一个对角元素，u1代表U矩阵中的第一行，v1转置代表V矩阵中的第一列</p>
<p>刚刚那个矩阵由于奇异值都相差不是很大，所以说“<span class="math inline">\(\Sigma\)</span>内的对角元素更多代表一种和原图像相似的一个权重”展示的可能不是那么明显。</p>
<p>如果我们将x轴延申80倍，然后y轴转换为原图的2倍看一看</p>
<p>图像就变为了这样的：</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmXMC.png" alt="img11"><figcaption>img11</figcaption>
</figure>
<p>最终的结果：</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmifg.png" alt="img11"><figcaption>img11</figcaption>
</figure>
<p>该图像对应原图的的变换矩阵为：</p>
<p><span class="math display">\[
 A =  \left|\begin{matrix}
    19.23018461 &amp; 16.54690303  \\
    53.21841786 &amp; 54.11284506
   \end{matrix} \right|
 \]</span></p>
<p>这样看来，似乎对y轴的操作看起来微乎其微，因为这些不同颜色的点已经几近贴合为一条线，那如果我们直接舍去对y轴的操作，</p>
<p>图像变为了这样：</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmrp1.png" alt="img11"><figcaption>img11</figcaption>
</figure>
<p>我们来看看该图像对应的变换矩阵为：</p>
<p><span class="math display">\[
 \sigma1\mu1v1=B =  \left|\begin{matrix}
    17.88854382 &amp; 17.88854382  \\
    53.66563146 &amp; 53.66563146 
   \end{matrix} \right|
 \]</span></p>
<p>B和A极其相似！</p>
<p>也就是说我们现在只保留最大的那个特征值，相乘后的结果与原图差别并不是很大，即<strong><em>该矩阵结果与原来的矩阵相差不是很大</em></strong>，很好的拟合了原矩阵的图像。</p>
<p>但我们依然来看看如果将第一个特征值抹去为0，只保留第二个奇异值来计算矩阵的大小C为多少？，由于矩阵相乘原理，其他地方置为0，保留第二个奇异值计算相当于将第二个奇异值乘以V的第二行然后乘以U的第二列。</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qaoh2.png" alt="qaoh2.png"><figcaption>qaoh2.png</figcaption>
</figure>
<p>在100x100的视窗里面，它似乎成了一个点，而且没有怎么动，与U sigma Vt的图像从视觉上看相差很大，而且C的结果也很小，与A矩阵相差很大（在这里C实际上就是A-B的结果）</p>
<p><span class="math display">\[
 \sigma2\mu2v2=C =  \left|\begin{matrix}
    1.34164079 &amp; -1.34164079  \\
    -0.4472136 &amp; 0.4472136
   \end{matrix} \right|
 \]</span></p>
<p>所以，现在你应该能够更能理解奇异值的大小更多的代表一种相似权重这个意思吧。SVD分解将<span class="math inline">\(\Sigma\)</span>的“头部”集中了更多的“<strong><em>质量</em></strong>”，忽略远离“头部”的奇异值对恢复矩阵的影响越小,也就是说我们在上面这个例子里面，只拿出第一个<span class="math inline">\(\Sigma\)</span>的值就能很好的相似拟合出原来A的矩阵，而可以舍去其他奇异值，因为它们对整个矩阵A的拟合影响不是很大，无论是从这个二维画图来看，还是从矩阵内的的数字大小来看都可以看出来。</p>
<h4 id="如何用python中的numpy计算svd">如何用Python中的Numpy计算SVD？</h4>
<p>Python中有一个Numpy库中，已经给我们内置了一个函数svd(matrix)可以直接求出一个矩阵的SVD分解后的U、<span class="math inline">\(\Sigma\)</span>、V</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> svd</span><br><span class="line">P = np.array([[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>]])</span><br><span class="line">U,S,V=svd(P)</span><br><span class="line">U</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.21472623,  0.37397651, -0.13150279, -0.89260362],
       [-0.5186023 , -0.70137666,  0.43020321, -0.23248147],
       [-0.48143993, -0.20822528, -0.83770916,  0.15199076],
       [-0.67317152,  0.56996016,  0.30963782,  0.35511962]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>
<pre><code>array([21.23135684,  6.43244475,  4.88175527,  0.14699287])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">V</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.55120987, -0.51992284, -0.48804478, -0.43319766],
       [ 0.26483885, -0.40006067,  0.65008996, -0.58923246],
       [ 0.07265877,  0.69537763, -0.21865293, -0.68070665],
       [ 0.78787611, -0.29339674, -0.53980203, -0.04222983]])</code></pre>
<p>可以看到，在使用Numpy进行SVD计算时，对角矩阵<span class="math inline">\(\Sigma\)</span>转化为了一个向量形式S的表达形式，如果要转化为矩阵形式，可以使用np.diag(S)函数进行转化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sigma1 = np.diag(S)</span><br><span class="line">sigma1</span><br></pre></td></tr></table></figure>
<pre><code>array([[21.23135684,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  6.43244475,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  4.88175527,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.14699287]])</code></pre>
<h4 id="奇异值包含了矩阵的本质信息">奇异值包含了矩阵的“本质信息”</h4>
<p>仔细看一看B矩阵，你能发现什么？</p>
<p><span class="math display">\[
 B =  \left|\begin{matrix}
    17.88854382 &amp; 17.88854382  \\
    53.66563146 &amp; 53.66563146 
   \end{matrix} \right|
 \]</span></p>
<p>没错，B是一个Rank为1的矩阵，实际上，当我们将每一项奇异值取出相乘再相加时，我们就是将多个Rank为1的矩阵相加</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-90a904448099ee0f3158bfa045012bb8_720w.jpg" alt="img5"><figcaption>img5</figcaption>
</figure>
<p>为什么说奇异值包含了矩阵的“本质信息”呢？</p>
<p>你看，如果一个矩阵“足够奇异”，那么我就只需要取出前几项奇异值对应的rank为1的矩阵相加就能很好的拟合出原矩阵，奇异值能够剖析矩阵的本质，深析这个原矩阵是个多少Rank的一个矩阵，也就是说矩阵越“奇异”，其行（或列）向量彼此越线性相关，越能彼此互相解释。即奇异值包含了矩阵的“本质信息”</p>
<p>这里也能间接告诉我们一个信息，那就是<span class="math inline">\(\Sigma\)</span> 内有多少个奇异值，原来的矩阵就是Rank为几的一个矩阵。</p>
<h4 id="在图像压缩上面的应用">在图像压缩上面的应用</h4>
<p>我们将尝试将这个爱心进行图像压缩</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qklNW.png" alt="qklNW.png"><figcaption>qklNW.png</figcaption>
</figure>
<p>这里需要提一下的是，我们都知道在电脑中一个图像就是由许多像素点组成的一个矩阵，所以上图的矩阵我们可以表达为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             ])</span><br></pre></td></tr></table></figure>
<p>0代表白色区域，1代表黑色区域</p>
<p>我们先利用Numpy中的svd函数将矩阵D的U,S,V值求出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">U,S,V=svd(D)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(U,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">sigma = np.diag(S)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(sigma,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(V,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[-0.36  0.   -0.73 -0.05  0.33  0.48]
 [-0.54 -0.35  0.27 -0.08 -0.58  0.4 ]
 [-0.54 -0.35  0.27 -0.08  0.58 -0.4 ]
 [-0.45  0.35 -0.27  0.52 -0.33 -0.48]
 [-0.28  0.71  0.18 -0.62 -0.   -0.  ]
 [-0.08  0.35  0.46  0.57  0.33  0.48]]

[[4.74 0.   0.   0.   0.   0.  ]
 [0.   1.41 0.   0.   0.   0.  ]
 [0.   0.   1.41 0.   0.   0.  ]
 [0.   0.   0.   0.73 0.   0.  ]
 [0.   0.   0.   0.   0.   0.  ]
 [0.   0.   0.   0.   0.   0.  ]]

[[-0.23 -0.4  -0.46 -0.4  -0.46 -0.4  -0.23]
 [-0.5  -0.25  0.25  0.5   0.25 -0.25 -0.5 ]
 [ 0.39 -0.32 -0.19  0.65 -0.19 -0.32  0.39]
 [-0.22  0.42 -0.44  0.42 -0.44  0.42 -0.22]
 [ 0.55 -0.44  0.09  0.   -0.09  0.44 -0.55]
 [-0.4  -0.55 -0.2  -0.    0.2   0.55  0.4 ]
 [ 0.2   0.1  -0.67  0.    0.67 -0.1  -0.2 ]]</code></pre>
<p>我们将<span class="math inline">\(\Sigma\)</span>中的第一个值4.74取出，计算这个rank1的矩阵</p>
<p><span class="math display">\[\sigma1\mu1v1\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">0</span>]*np.outer(U[:,<span class="number">0</span>],V[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[0.39 0.68 0.78 0.68 0.78 0.68 0.39]
 [0.59 1.02 1.17 1.02 1.17 1.02 0.59]
 [0.59 1.02 1.17 1.02 1.17 1.02 0.59]
 [0.48 0.84 0.97 0.84 0.97 0.84 0.48]
 [0.3  0.52 0.6  0.52 0.6  0.52 0.3 ]
 [0.09 0.16 0.18 0.16 0.18 0.16 0.09]]</code></pre>
<p>取第二个奇异值1.41，计算出<span class="math display">\[\sigma2\mu2v2\]</span>，取第三个奇异值1.41，计算出<span class="math display">\[\sigma3\mu3v3\]</span>....我们看到奇异值非0数只有4个，说明原矩阵是一个rank为4的矩阵，当我们取到第四个奇异值<span class="math display">\[\sigma4\mu4v4\]</span>将再将这些所有的秩一矩阵相加即可还原原矩阵D的图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">1</span>]*np.outer(U[:,<span class="number">1</span>],V[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[-0.   -0.    0.    0.    0.   -0.   -0.  ]
 [ 0.25  0.13 -0.13 -0.25 -0.13  0.13  0.25]
 [ 0.25  0.13 -0.13 -0.25 -0.13  0.13  0.25]
 [-0.25 -0.13  0.13  0.25  0.13 -0.13 -0.25]
 [-0.5  -0.25  0.25  0.5   0.25 -0.25 -0.5 ]
 [-0.25 -0.12  0.13  0.25  0.13 -0.12 -0.25]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">2</span>]*np.outer(U[:,<span class="number">2</span>],V[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[-0.4   0.33  0.2  -0.67  0.2   0.33 -0.4 ]
 [ 0.15 -0.12 -0.07  0.25 -0.07 -0.12  0.15]
 [ 0.15 -0.12 -0.07  0.25 -0.07 -0.12  0.15]
 [-0.15  0.12  0.07 -0.25  0.07  0.12 -0.15]
 [ 0.1  -0.08 -0.05  0.17 -0.05 -0.08  0.1 ]
 [ 0.25 -0.21 -0.12  0.42 -0.12 -0.21  0.25]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">3</span>]*np.outer(U[:,<span class="number">3</span>],V[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0.01 -0.02  0.02 -0.02  0.02 -0.02  0.01]
 [ 0.01 -0.02  0.03 -0.02  0.03 -0.02  0.01]
 [ 0.01 -0.02  0.03 -0.02  0.03 -0.02  0.01]
 [-0.08  0.16 -0.17  0.16 -0.17  0.16 -0.08]
 [ 0.1  -0.19  0.2  -0.19  0.2  -0.19  0.1 ]
 [-0.09  0.17 -0.18  0.17 -0.18  0.17 -0.09]]</code></pre>
<p>我们看到，在<span class="math display">\[\sigma4\mu4v4\]</span>时，这个矩阵内的数字大小已经很小，几近为0了。</p>
<p>在算<span class="math display">\[\sigma5\mu5v5\]</span>时，由于奇异值<span class="math inline">\(\sigma5\)</span>以及为0，所以该<span class="math display">\[\sigma5\mu5v5\]</span>以及为一个零矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">4</span>]*np.outer(U[:,<span class="number">4</span>],V[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0. -0.  0.  0. -0.  0. -0.]
 [-0.  0. -0. -0.  0. -0.  0.]
 [ 0. -0.  0.  0. -0.  0. -0.]
 [-0.  0. -0. -0.  0. -0.  0.]
 [-0.  0. -0. -0.  0. -0.  0.]
 [ 0. -0.  0.  0. -0.  0. -0.]]</code></pre>
<p>我们计算可以得出 <span class="math display">\[
 result = D =\sigma\mu1v1+\sigma2\mu2v2+\sigma3\mu3v3+\sigma4\mu4v4\]</span></p>
<p>我们来看看<span class="math display">\[\sigma x\mu xvx\]</span></p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qkoki.png" alt="qkoki.png"><figcaption>qkoki.png</figcaption>
</figure>
<p>将每一个秩1矩阵相加起来的图像</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qnQSF.png" alt="qnQSF.png"><figcaption>qnQSF.png</figcaption>
</figure>
<p>可以清晰看到，加到第四个矩阵时，我们就已经得到与原图像（原矩阵）一模一样的图像（矩阵）</p>
<p>这个图像比较小，8x8图像，该图像可能无法让你感觉到奇异值的重要性。</p>
<p>但如果说我们的矩阵是一个1000x1000的图像（一般电脑的图片比这个还要大），如果我们要记录这个图片，我们原本需要电脑记录1000x1000=1000000个像素！也就说一张照片我们需要存入一百万个值。</p>
<p>但如果我们用到了SVD分解，将图片转化为4个秩1的矩阵相加的情况，我们只需要保留2000x4=8000个像素就能完全呈现一个一模一样的原图。</p>
<p>如果我们准备将图片压缩，我们可以舍去后两个秩1矩阵，因为我们之前已经说了<span class="math inline">\(\Sigma\)</span>头部的值往往代表了这个图片的“本质信息”，那就只需要保留2000x2=4000个像素数据就能差不多拟合出原图的照片。</p>
<p>但往往很多时候我们交给计算机处理视觉问题时并不需要一个清晰度极其高的一张图片，这和人类的视觉系统类似。</p>
<p>比如给你这样一张图片</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qn9WQ.jpg" alt="qn9WQ.jpg"><figcaption>qn9WQ.jpg</figcaption>
</figure>
<p>(希望没有吓到你)</p>
<p>虽然很模糊，但你还是知道它是一只狗。</p>
<p>所以让计算机去处理这些视觉问题时，我们往往只要勾勒出原图的一个模糊图像，能够近似拟合原图的一个图像就行了，这就与SVD分解息息相关。</p>
<p>当然，SVD的应用远不止如此，SVD在图像恢复、PCA、异常检测、图像去噪、推荐系统、SLAM都有着巨大的作用。</p>
<p>感兴趣的话可以去搜一搜，关于SVD分解的数学讲解将放在下一章。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>安装mayavi遇到的一些问题</title>
    <url>/2022/07/19/mayavi/</url>
    <content><![CDATA[<p>mayavi库相较于matplot能够更好的展现3D的视图，最近在学习python的时候要用到mayavi这个库，由于我本人用的是anaconda版本的python，默认python版本是3.8.8版本的，下了mayavi却一直报错，后来去查了查应该是python版本问题，于是搞了个3.7版本的虚拟环境，直接在anaconda下载mayavi仍然一直报错，后来尝试了直接在cmd上pip install等等方法都不可行，搞了一晚上还没搞清楚。</p>
<p>这个过程我也遇到了很多网上相似的问题，但是解决方案回答在互联网上好像很少，我把我的解决流程发上来，供各位参考。</p>
<p>后来干脆手动安装whl的包</p>
<p>安装地址：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">pythonlibs</a></p>
<p>下载内容：mayavi，PyQt4，traits，VTK</p>
<p>这里需要注意的是下载的包必须是匹配的。</p>
<p>避免失误的话，这里你可以参考我的下载的包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mayavi-<span class="number">4.7</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">PyQt4-<span class="number">4.11</span><span class="number">.4</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">traits-<span class="number">6.3</span><span class="number">.1</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">VTK-<span class="number">9.0</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<p>安装mayavi并不难，关键是mayavi所依赖的环境复杂，前期我下载的时候是胡乱安装的，导致我运行程序的时候一直报错。</p>
<p>将下载的四个文件的文件夹通过3.7的虚拟环境打开，然后直接输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mayavi-<span class="number">4.7</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">pip install PyQt4-<span class="number">4.11</span><span class="number">.4</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">pip install traits-<span class="number">6.3</span><span class="number">.1</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">pip install VTK-<span class="number">9.0</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>以上的解决方案在互联网上已经有了，下面是一些我遇到的问题。</p>
<h4 id="报错attributeerror-type-object-dialogcode-has-no-attribute-accepted解决方案">报错AttributeError: type object 'DialogCode' has no attribute 'Accepted'解决方案</h4>
<p>在命令端下载PyQt5以及PyQt5配套的tools库即可。</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/20/DoAiQ.png" alt="DoAiQ.png"><figcaption>DoAiQ.png</figcaption>
</figure>
<p>然后将pyqt5_tools文件的地址添加到path变量里面即可。</p>
<h4 id="vtk版本不匹配解决方案">VTK版本不匹配解决方案</h4>
<p>WARNING: Imported VTK version (9.1) does not match the one used</p>
<p>to build the TVTK classes (9.0). This may cause problems.</p>
<p>Please rebuild TVTK.</p>
<p>解决办法：将现版本的VTK（9.1)uninstall，然后install 9.0版本的VTK</p>
<p>直接在命令端输入</p>
<p>pip uninstall VTK==9.1</p>
<p>待完成以后再输入</p>
<p>pip install VTK==9.0</p>
<h4 id="检测mayavi.mlab是否正常运行">检测mayavi.mlab是否正常运行</h4>
<p>在ipython中输入：</p>
<p>from mayavi import mlab</p>
<p>如果不报错即成功解决问题</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记 1 - 什么是Git？</title>
    <url>/2022/07/21/git1-1/</url>
    <content><![CDATA[<hr>
<h3 id="一.什么是git">一.什么是Git？</h3>
<p>作为一名开发人员，在日常开发中，我们能经常见到Git这个字眼，那么Git到底是什么？为什么那么重要？在开发过程中为什么需要用到它？在我们开始学习Git之前，这些东西是我们需要知道的。接下来的文字也许能让你进一步理解Git的它的历史演变以及它的重要性。</p>
<p>Git是一个<strong>分布式版本控制系统</strong>。</p>
<p>什么是版本控制系统？一个很简单的例子，在你编辑文档的时候，因为某些失误，你把一个很重要的信息给删掉了，你并不着急，因为你此时可以选择撤销按钮，将之前误删的信息给还原。</p>
<p><img src="https://is1-ssl.mzstatic.com/image/thumb/Purple114/v4/26/5d/8d/265d8db0-5081-2d57-482f-d3baa615f536/AppIcon-0-1x_U007emarketing-0-7-0-sRGB-0-0-0-85-220-0.png/1200x630wa.png"></p>
<p>其实可以这样理解，你的每一个操作，对于文档来说就是一个独立的“版本”。</p>
<p>现在很多信息的填写，都用到了“共享文档”这个体系，其实就是避免了多方对信息的处理不一致导致的冲突，我在编辑文档的同时也能看得见你的编辑。但放在多年前，如果一个文档你需要别人对其进行一些增删改查，而你在别人帮你修改的同时自己也将文档增添润色了一下，等到别人把已经改正的文档发给你时，你怎么知道他改了哪些地方，哪些地方和你润色后的版本有了冲突呢？</p>
<p>而分布式，就是<strong>非集中式</strong>（对，这是句废话）</p>
<p>以往的集中式，特别繁琐，需要有一个中央服务器，如果要进行修改，要先得到中央服务器的服务版本，然后修改以后再推给中央服务器，是一种自上而下的版本管理方式。像SVN，CVS 等这些版本管理系统就是集中式的。</p>
<p>而分布式，不需要进行联网可以进行修改操作（工作区），然后再提交给其他服务器（电脑），这时候不需要一个中央服务器的存在，而是每一个独立的电脑就是一个独立的服务器。</p>
<p>这时候就要Git登场了。</p>
<h4 id="git的诞生">1.Git的诞生</h4>
<p>Linus 建立了开源 Linux以后，依然要管理从世界各地志愿者为 Linux编写的代码，全世界那么多代码，初期Linus确实是靠自己个人管理的，后来Linux越来越壮大，代码量如此之大，是时候选一个<strong>版本控制系统</strong>来管理这些代码了，之前为什么不选择使用CVS、SVN这些<strong>集中式</strong>版本控制系统，原因是因为这些系统不仅速度慢，而且必须通过联网才能使用。其他的商用控制系统Linus不选，因为与Linux开源精神极其不符。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上.（1991－2002年间）</p>
<p>这时候BitKeeper愿意免费为Linux社区提供免费的版本控制服务，但作为具有巨大开源精神的Linux社区志愿者们多次尝试破解BitKeeper的协议...</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使Linus Torvalds重新思考如何管理这些世界各地的代码。</p>
<p>两周后，分布式控制系统Git在Linus的家中诞生。</p>
<p><img src="https://imgix.gizmodo.com.au/content/uploads/sites/2/2018/01/linusfinger.jpg?ar=16:9&amp;auto=format&amp;fit=crop&amp;q=65&amp;w=1280"></p>
<h3 id="二.git的安装">二.Git的安装</h3>
<p>访问<a href="https://git-scm.com/downloads">Git官网</a> 下载对应的系统版本，由于我本人使用的是Windows版本，故下载Git for windows版本。</p>
<hr>
<hr>
<p>本笔记参考了以下教材：</p>
<p>1.<a href="https://git-scm.com/">Git官方文档</a></p>
<p>2.<a href="https://www.liaoxuefeng.com/">廖雪峰Git博客教程</a></p>
<hr>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记 2 - 在本地使用Git</title>
    <url>/2022/07/23/git2/</url>
    <content><![CDATA[<hr>
<h3 id="创建版本库仓库">创建版本库（仓库）</h3>
<p>版本库，即repository，也可以说成是仓库。创建一个仓库被git管理起来以后，你在这个<strong>仓库的每一时刻的操作都会被追踪、记录、提交、还原。</strong></p>
<h4 id="git-init">git init</h4>
<p>选择一个任意的地方，创建一个文件（目录）,然后在这个空目录中右键选择 “git bash here&quot;选项，输入<code>git init</code> 这样我们就完成了对该目录的git初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in F:/gittest/.git/</span><br></pre></td></tr></table></figure>
<h3 id="添加文件到仓库">添加文件到仓库</h3>
<h4 id="git-add-git-commit">git add / git commit</h4>
<p>我们在该目录下新建一个txt文件，在里面输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello git！</span><br></pre></td></tr></table></figure> <img src="/2022/07/23/git2/git-1.PNG"></p>
<p>然后我们再执行以下命令将该更新上传到仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m&quot;wrote a test file&quot;</span><br><span class="line">[master (root-commit) 9857814] wrote a test file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>这里的 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add</span><br></pre></td></tr></table></figure> 是指将修改上传到我们的<strong>暂存区</strong>（此时可以暂时忽略，稍后会讲到） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure> 是做本次更新的声明，并且将<strong>暂存区</strong>中的修改上传到<strong>版本库</strong>中，更新的声明在-m后输入，这个声明平常不要乱写，为了以后方便修改、查询。</p>
<p>当我们提交了本次更新的声明以后，命令行出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>此时，我们暂存区中的内容就已经成功上传到了版本库中。</p>
<p>指出这次更新共有一个文件被更改，此次进行了一个插入操作（即我们对空文档进行了插入 Hello git！的操作）</p>
<p>总结来说，每次我们将更新上传到仓库中操作有两步，</p>
<p>第一步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add (file name)</span><br></pre></td></tr></table></figure>
<p>第二步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查看此时的仓库状态">查看此时的仓库状态</h3>
<h4 id="git-status">git status</h4>
<p>此时，我们在命令行输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure> 此时，命令行告诉我们 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>在分支 <code>master</code>上，没有什么需要去更新上传的，工作目录是干净的。</p>
<p>此时，如果我们对<code>test.txt</code>文档进行一下修改。</p>
<p>增添一句 i love git!</p>
<p><img src="/2022/07/23/git2/git-2.PNG"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>这个时候命令行告诉了我们在分支<code>master</code>上产生了一个更改但是没有上传（not staged for commit）并且告诉了我们如何从工作区（working area）上传到版本库中（git direcotory）。</p>
<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态。</p>
<h3 id="查看我们的更新日志">查看我们的更新日志</h3>
<p>我们再增删一下<code>test.txt</code>的内容，改为下面这样。</p>
<p><img src="/2022/07/23/git2/git-8.PNG"></p>
<h4 id="git-log">git log</h4>
<p>此时，我们在命令行输入<code>git log</code>可以看到我们的所有<code>commit</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit fdfc94c2abdcaa55fdf2255dae2b7d0cd83c08bb (HEAD -&gt; master)</span><br><span class="line">Author: Cherleng &lt;2501687225@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 28 15:02:20 2022 +0800</span><br><span class="line"></span><br><span class="line">    append really</span><br><span class="line"></span><br><span class="line">commit 13221dae0aee03c5db614ae3232716e078ce65c6</span><br><span class="line">Author: Cherleng &lt;2501687225@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 28 14:59:53 2022 +0800</span><br><span class="line"></span><br><span class="line">    update 2</span><br><span class="line"></span><br><span class="line">commit 98578141519e1abbb6d6f76d0f03cdb2de86c556</span><br><span class="line">Author: Cherleng &lt;2501687225@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 28 14:38:02 2022 +0800</span><br><span class="line"></span><br><span class="line">    wrote a test file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到我们进行了三次提交。</p>
<p><code>commit</code>后面的一大串数字代表我们此次更新的版本号，这个版本号可以让我们随时“穿越”到任何一个<code>commit</code>过的修改。(注意：这里能穿越的一定是我们已经comiit上传到版本库的版本，如果没有进行<code>commit</code>操作，我们是无法穿越的)</p>
<h4 id="git-reset">git reset</h4>
<p>使用<code>git reset --hard(版本号)</code>就可以回退到任何一个已经被提交的修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 13221</span><br><span class="line">HEAD is now at 13221da update 2</span><br></pre></td></tr></table></figure>
<p>此时我们再打开<code>test.txt</code> 发现里面的内容以及变成了我们第二次修改时候的内容。</p>
<p><img src="/2022/07/23/git2/git-9.PNG"></p>
<p>此时我们再看一看此时的日志记录信息(<code>git log</code>)</p>
<p><img src="/2022/07/23/git2/git-10.PNG"></p>
<p>可以看到，这个时候我们的日志信息中没有了第三次“append really”的操作，并且我们的<code>HEAD</code>指针指向了我们的第二次修改（commit ID：13221）的位置。</p>
<p><img src="/2022/07/23/git2/gitreset10.png"></p>
<p>如果这个时候要重新返回第三次修改的位置但是不知道第三次版本号，使用&quot;<code>git reflog</code>&quot;可以观察到我们操作的所有版本ID，让我们可以随时返回到之前的位置。</p>
<p><img src="/2022/07/23/git2/git11.PNG"></p>
<p><code>HEAD-&gt;</code> 指针指向的就是我们当前的分支。</p>
<p><code>master</code> 代表我们此时操作的分支（branch），指向该分支此时操作的节点，默认情况下没有改变分支的话，我们在初始化git的时候创建的就是<code>master</code>分支，Git允许我们在分支的历史节点之间穿梭。</p>
<p><img src="/2022/07/23/git2/head.png"></p>
<h4 id="git-diff">git diff</h4>
<p>此时，我们再修改一下<code>test</code>文件，在末尾加一行“i hate git&quot;</p>
<p><img src="/2022/07/23/git2/hate.PNG"></p>
<p>此时我们如果要查看现在工作区与版本库之间的差别，可以输入&quot;<code>git diff</code>&quot;来查看工作区与版本库之间的差别。</p>
<p><img src="/2022/07/23/git2/diff.PNG"></p>
<h4 id="git-restore">git restore</h4>
<p>我刚刚输入了“I hate git”，但现在我想还原到版本库中已经<code>commit</code>的没有“I hate git”这一行的那个版本，该怎么办呢？</p>
<p>Git中仍然可以使这件事轻松的做到。</p>
<p>我们在命令行中输入 <code>$git restore</code> 就可以让工作区的文件版本回到最近的一次版本库中的版本。</p>
<p><img src="/2022/07/23/git2/restore.PNG"></p>
<p>这时候再重新打开<code>test</code>文件，你会发现刚刚的“I hate git”已经被删除了，文件成功重新回到了最近的一次版本库中的版本。</p>
<h4 id="why">why？</h4>
<p>为什么Git能够帮助我们在任何版本历史之间穿梭呢？这就涉及到Git不一样的工作原理了。</p>
<h3 id="工作区与版本库">工作区与版本库</h3>
<p>工作区就是我们暂时工作的可以观察到的目录。</p>
<p>工作区中在我们初始化Git的时候生成了一个隐藏文件&quot;.git&quot;，这个就是我们本地的版本库。版本库安全的存放了我们文件的数据</p>
<p><img src="/2022/07/23/git2/git-3.PNG"></p>
<p>版本库内就有一个index（stage），我们的暂存区。</p>
<p>工作区是我们直接操作的地方。每一次我们操作完成在命令行<code>add</code>文件的时候，这个时候文件实际上是被<code>add</code>到了暂存区，而非真的添加到了git版本库中，我们要继续<code>commit</code>，文件才真正的被存入了版本库中。所以说<strong>暂存区保存了下次将提交的文件列表信息。</strong></p>
<p><img src="/2022/07/23/git2/git-basic-workflow-codesweetly.png"></p>
<p>我们在目录中继续创建一个“<code>test2.txt</code>”文件，而不进行<code>git add</code>操作，<code>git status</code>告诉我们发现了一个“<code>Untracked files</code>&quot;test2。</p>
<p><img src="/2022/07/23/git2/git-5.PNG"></p>
<p>如果我们此时进行<code>git commit</code> 的话，test2是不会提交到版本库中的，因为test2没有进行<code>add</code>操作，也就是说test2这个文件是没有进入我们的暂存区的,自然也就无法上传到版本库中。</p>
<p>所以，我们任何的时间回跳操作其实是因为我们可以在工作区与版本库之间进行“交易”，并且每一次“交易”都有专属的交易代码，让我们在各个“时空”中切换自如。</p>
<p><img src="/2022/07/23/git2/keepcalm.png"></p>
<h3 id="深入了解文件的几种状态">深入了解文件的几种状态</h3>
<p>现在我们已经大致的了解了git在本地的一些操作，这个过程初学者可能会觉得有些繁琐复杂，所以在学习任何一门工具的过程中，最重要的是进行实战，自己去体验这个过程，在体验中也就加深了对这个框架的理解，自然也就能在未来的使用中游刃有余。</p>
<h4 id="untracked">Untracked</h4>
<p>我们重新建立一个工作目录，在目录中新建一个<code>test.txt</code>文件。此时不进行任何操作，用status查看仓库状态。</p>
<p><img src="/2022/07/23/git2/Untracked.PNG"></p>
<p>命令行提示我们这是一个<strong>未被追踪的文件</strong>（untracked files)，即该文件存在于我们的工作目录中，但没有上传到git仓库中，自然是不参与版本控制的。</p>
<p>使用<code>git add</code>，文件状态就会变为<code>staged</code>（<strong>在暂存区中暂存</strong>）</p>
<h4 id="staged">staged</h4>
<p>文件处于<code>staged</code>暂存状态时，可以进行<code>commit</code>入库，入库后文件状态变为<code>Unmodified</code>。</p>
<p>或者使用<code>git reset HEAD</code>命令或者<code>git restore --</code>命令取消<code>staged</code>暂存状态，此时文件变为<code>modified</code>的状态。</p>
<h4 id="modified-unmodified">Modified / Unmodified</h4>
<p>我们将刚刚的文件<code>commit</code>入库，再修改一下文件内容，然后再看一下此时的状态。</p>
<p><img src="/2022/07/23/git2/modified.PNG"></p>
<p>此时告诉我们在<code>test</code>这个文件里面发生了<code>modified</code>修改，也就是此时工作区的<code>test</code>文件和git库中的版本不一样，但是没有进行任何操作，命令行提示我们此时有两种操作，可以使用<code>git add</code>将该文件从<code>Modified</code>状态变为<code>staged</code>状态，或者使用<code>git restore</code>丢弃工作区的修改,此时文件状态将从<code>modified</code>变为<code>Unmodified</code>,即此时工作区的状态和版本库内一致。</p>
<p><img src="/2022/07/23/git2/4.png"></p>
<p>参考目录：</p>
<ul>
<li><a href="https://git-lectures.github.io/#">git-lectures</a></li>
<li><a href="https://git-scm.com/book/en/v2">Git官方文档</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git教学</a></li>
<li><a href="https://www.cnblogs.com/thirteen-yang/p/13878118.html">Git中文件的4种状态Untracked、Unmodify、Modified、Staged</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记 - 远程使用Git(使用Github)</title>
    <url>/2022/08/01/git3/</url>
    <content><![CDATA[<p>在上一讲中我们已经大致了解了如何在本地使用git为我们的目录做版本控制管理。但是很显然，在多人合作项目当中，我们不可能只在一台电脑上操作，所以我们也要知道如何远程使用Git。</p>
<p>远程多人协作，自然需要一个24小时运行的服务器为我们的“心脏”保驾护航，这样我们才能从任何一个地方提交到这个“中心”，并且从这个“中心”获取最新的更新。</p>
<p>但是幸运的是我们不需要再多置备一台服务器，Github可以为我们的项目进行托管服务。</p>
<p><img src="/2022/08/01/git3/github.jpg"></p>
<p>在利用Github对我们的项目进行托管前我们需要设置<code>SSH key</code> 与创建一个Github repository。</p>
<p>将我们电脑的<code>SSH key</code>生成后提交到我们的github账号上，这样我们电脑的Git仓库与Github仓库之间就建立了传输关系，我们就能把我们在本地的操作提交到远程Github仓库上面。</p>
<p>同理，如果在另一台电脑上进行此操作也可以将另一台电脑与Github仓库建立关系，我们就可以在任何一台电脑上面对我们的Github仓库进行操作。这样，我们就可以实现多人协作控制项目仓库。</p>
<h3 id="建立一个github远程仓库">建立一个Github远程仓库</h3>
<p><img src="/2022/08/01/git3/new_repo.PNG"></p>
<p>当我们在Github注册了一个账号之后，我们进入<code>Repositories</code>页面中，单机页面右上角的<code>New</code>按钮，创建一个新的仓库。</p>
<p><img src="/2022/08/01/git3/new.png"></p>
<p>此时，我们按照Github页面的提示让本地的仓库与这个远程仓库进行关联。</p>
<p><img src="/2022/08/01/git3/exist.PNG"></p>
<p>我们在我门的本地目录里面输入<code>git remote add origin git@github.com:Cherleng/git_test.git</code>就能让该目录与该远程仓库关联。</p>
<h3 id="github远程仓库的操作">Github远程仓库的操作</h3>
<h4 id="git-push">git push</h4>
<p>使用<code>git push [alias] [branch]</code>命令，可以将本地的<code>branch</code>分支提交到<code>alias</code>远程仓库中的<code>branch</code>分支。</p>
<p><img src="/2022/08/01/git3/push.PNG"></p>
<p>此时，我们再看一下我们的github仓库，就可以看到<code>test.txt</code>文件已经上传到这里了！</p>
<p><img src="/2022/08/01/git3/afterpush.PNG"></p>
<p>所以，一个push操作的大致流程就是<code>new -&gt; add -&gt; commit -&gt; push</code></p>
<h4 id="git-remote">git remote</h4>
<p>利用<code>git remote</code>来看到我们远程仓库的别名，利用<code>git remote -v</code>可以看到远程仓库的具体信息</p>
<p><img src="/2022/08/01/git3/remote.PNG"></p>
<h4 id="git-pull">git pull</h4>
<p>我们先在github仓库页面对test.txt进行一下修改，我们在最后一行加入<code>i hate git</code>。</p>
<p><img src="/2022/08/01/git3/hate.PNG"></p>
<p>此时我们再从本地尝试push到github仓库。</p>
<p><img src="/2022/08/01/git3/pusherror.PNG"></p>
<p>此时命令行就报错了，告诉我们这次push操作被拒绝了,原因是在我们之前已经有一个远程提交，命令行提示我们可以使用<code>git pull</code>命令从远程仓库分支抓取下来，然后在本地解决冲突，再推送。</p>
<p><img src="/2022/08/01/git3/pull.PNG"></p>
<p>此时，我们打开<code>test.txt</code>文件，就可以看到最下面一行增添了<code>i hate git!</code></p>
<p>解决冲突后，再进行Push操作，就能够成功的推送到远程仓库了。</p>
<p>总结来讲，下面这张图就能很好的让我们了解本地与远程的操作线是如何的走了。</p>
<p><img src="/2022/08/01/git3/localtoremote.png"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记4 - 什么是分支？</title>
    <url>/2022/08/01/git4/</url>
    <content><![CDATA[<p>到现在，我们已经知道如何在本地以及远程使用git，但整个过程我们都没有谈及<code>branch</code>这个东西，由于在git初始化的时候建立的分支就是<code>master</code>，所以我们一直操作并且提交的也是<code>master</code>分支，那分支到底有什么用呢？</p>
<p>实际上，在多人协作以及本地使用git时，分支是一个非常重要的东西。故名思意，分支就是在一个“主线”上面，在某一个“点”分开，并且在某一“点”做的一个延伸、一个“分线”。</p>
<p>有“分”，自然有“合”，在某个“点”我们又可以把各个分支合并起来，汇聚到这条“主线”上面。</p>
<p>就像一条奔腾的大河，在某个节点的时候可能会分出很多道小溪，而这些小溪在自己的运动轨道上漂流着，并不会影响其他小溪（大河）的运作，而在某个节点，又能重新和其他小溪（大河）汇聚起来。</p>
<p>这样一想，分支在项目开发中就显得极为重要了。因为在项目开发中，如果每个人都用<code>master</code>这条进行操作，那会让主线变得十分混乱，我们应该在某个节点，每个人分出一条线对项目进行修改，然后再在某个时间点合并到主工作线上，这样既清晰又减少了项目合作中出现的混乱。</p>
<p><img src="/2022/08/01/git4/git-branches-merge.png"></p>
<h4 id="git-branch">git branch</h4>
<p>使用<code>git branch [name]</code>命令可以建立一个名为<code>name</code>的分支</p>
<p>使用<code>git branch</code>命令可以查看现在的分支情况，前面带有<code>*</code>表示当前正在操作的分支.</p>
<p><img src="/2022/08/01/git4/branch.PNG"></p>
<h4 id="git-checkout-branchname">git checkout (branchname)</h4>
<p>使用<code>git checkout (branchname)</code>可以切换分支。</p>
<p><img src="/2022/08/01/git4/checkout.PNG"></p>
<p>我们此时对<code>test.txt</code>做一些修改，比如在最后一行加入&quot;<code>Hello,edliu!</code>&quot;并且将其上传到本地版本库中。</p>
<p><img src="/2022/08/01/git4/append.PNG"></p>
<p>因为我们上传的是<code>test</code>分支，对于<code>master</code>分支，仍然还停留在上一个操作阶段，我们可以从<code>git log</code>命令清晰看出来。</p>
<p><img src="/2022/08/01/git4/branch2.PNG"></p>
<p>命令行告诉我们此时<code>HEAD</code>指针指向<code>test</code>分支。</p>
<p>现在我们使用<code>git checkout master</code>将分支切换为<code>master</code>，我们会发现刚刚在最下面加的<code>Hello,edliu</code>并未存在。</p>
<h4 id="git-merge">git merge</h4>
<p>可以使用<code>git merge [name]</code>将名为<code>name</code>的分支合并到当前分支。</p>
<p><img src="/2022/08/01/git4/switch.PNG"></p>
<p>此时打开test文件，最下面一行就出现了<code>Hello,edliu!</code>。</p>
<h4 id="处理合并冲突">处理合并冲突</h4>
<p>我们在<code>master</code>分支下对文件进行一下修改,并且上传到本地版本库中。</p>
<p><img src="/2022/08/01/git4/hello.PNG"></p>
<p>我们再切换为<code>test</code>分支对文件进行一下修改，并且上传到本地版本库中。</p>
<p><img src="/2022/08/01/git4/goodbye.PNG"></p>
<p>此时，我们尝试在<code>test</code>分支中将<code>master</code>分支的内容合并过来，但是命令行告诉我们这个合并在<code>test.txt</code>这个文件上出现了冲突，并且告诉我们处理冲突后再进行合并。</p>
<p><img src="/2022/08/01/git4/mergeconflict.PNG"></p>
<p>上几节已经讲过，我们可以用<code>git diff</code>来查看二者的冲突在哪。</p>
<p><img src="/2022/08/01/git4/conflict.PNG"></p>
<p>此时告诉我们<code>HEAD-&gt;</code>指针指向的分支（<code>test</code>)和<code>master</code>分支的冲突是因为一个是<code>Goodbye git!</code>,一个是<code>hello git</code>。</p>
<p>发生冲突时，我们只要将<strong>发生冲突的文件</strong>修改为我们需要的正确的版本，再进行<code>add</code>和<code>commit</code>就解决了冲突。</p>
<p><img src="/2022/08/01/git4/helloand.PNG"></p>
<p><img src="/2022/08/01/git4/end.PNG"></p>
<p>合并冲突就这样成功解决了！</p>
<p>也就是说，在发生冲突的时候，解决冲突实际上就是对当前文件重新再进行一次commit操作。</p>
<p><img src="/2022/08/01/git4/jieshi.png"></p>
<p>我们可以通过<code>git log --graph</code>命令来查看合并流程图。</p>
<p><img src="/2022/08/01/git4/graph.PNG"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习 - 动态规划 Dynamic Programming</title>
    <url>/2022/11/18/dynamic-program/</url>
    <content><![CDATA[<h4 id="一.什么是动态规划">一.什么是动态规划？</h4>
<hr>
<p>我们先来看一下wiki上面对于动态规划的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</span><br></pre></td></tr></table></figure>
<p>就是说，动态规划是一种<strong>方法</strong>，用于解决复杂问题时将复杂问题转化为一个个<strong>相似的小问题</strong>，所有的问题都只需要计算一次，并且<strong>储存</strong>它们的解。</p>
<p>很多人学完动态规划后，常常不知所用，不知道该在什么样的情况下面用到动态规划，或者可以说，根本不了解动态规划这个方法的意义所在。所以我们可以在各个平台上面看到对动态规划的人生三问：什么是动态规划？为什么要用动态规划？动态规划的意义是什么？动态规划要往哪里去？</p>
<p><img src="/2022/11/18/dynamic-program/question.PNG"></p>
<p>为什么很多人学完动态规划后都有这样的困惑呢？因为刚刚Wiki上面的解释已经很清楚了，动态规划是一种<strong>方法</strong>，动态规划并不是一种一成不变的算法。</p>
<p>有些算法，比如DFS、BFS算法，你甚至只需要去理解以后记住这个算法的模板，怎么去用，在哪些情况下用，以后遇到类似的问题，将模板转化一下就可以用了。但动态规划不是，这就是动态规划的迷雾所在，有些题你在看了题解以后发现这道题居然能够用动态规划的思路去做，你不禁感叹：动态规划真是好东西...</p>
<p>按照我个人的理解来说，动态规划就是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动态规划就是一种将一个大问题分解为各个独立的小问题，建立一个可保存数据的结构（通常是数组）来缓存小问题已经得出的结果，并且在后面通过一个归纳的方程（即状态转移方程）复用这个结果，得出大问题的结果的一种方法。</span><br></pre></td></tr></table></figure></p>
<p>如果觉得这段话很绕也没事，注意几个关键字 &quot; <strong>缓存数据</strong> <strong>复用数据</strong> <strong>状态</strong> <strong>转移方程</strong> <strong>方法</strong> &quot; ，这些就是动态规划的要义所在。</p>
<p>我再来举一个我在网上看到的一个比较幽默的例子吧，也很好的说明了什么是动态规划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q：（1+1+1+1+1+1+1+1+1+1+1） = ?</span><br><span class="line"></span><br><span class="line">A：（你一个一个数了，很慢的回答）等于11</span><br><span class="line"></span><br><span class="line">Q：（1+1+1+1+1+1+1+1+1+1+1）+1=？</span><br><span class="line"></span><br><span class="line">A：（你只看到右边多了个+1，快速回答了）等于12</span><br></pre></td></tr></table></figure>
<p>为什么第二次你不需要一个一个数到底有多少个“1”在等式左边呢？因为第一次问你的时候，你数了，知道等于11。第二次在左边加了个1，对于你来讲，就是问你：11+1=？ 于是你几乎不需要停留，脱口而出：“12”。（恭喜你，达到了小学一年级的水平）</p>
<p>回到正题，这个例子其实就是在阐述<strong>缓存数据</strong>（缓存了前面的11）、<strong>复用数据</strong>（用到了前面缓存的11）、<strong>转移方程</strong>（在这个例子里就是呈现的算术）这些动态规划的<strong>核心</strong>。</p>
<h4 id="二.什么问题能用到动态规划">二.什么问题能用到动态规划？</h4>
<p>什么情况下能用到动态规划？</p>
<p>就是<strong>满足最优子结构、无后效性</strong>的时候。</p>
<p>浅显的说，一个问题如果大问题(原问题）<strong>能够分解</strong>为一个个小问题，小问题可以拆分为<strong>更小的问题</strong>，同时，大问题的最优解能够通过小问题的最优解<strong>递推得到</strong>、小问题的答案可以由更小的问题的最优解<strong>递推得到</strong>（这个大与小指规模的大小），这就是满足“<strong>最优子结构</strong>”的问题。</p>
<p>在这里大问题的结果，我们<strong>只看</strong>小问题的答案，而<strong>不用考虑</strong>小问题的答案是如何得到的，这就是满足“<strong>无后效性</strong>”的问题。即</p>
<p><strong>“现在就是过去的总结，现在决定未来，未来与过去无关。”</strong></p>
<p>那么这个问题就能够通过动态规划的思想来解决。</p>
<p>现在不理解这两个术语意思没事，后面根据一些例子大概就能很好的了解了。</p>
<p><img src="/2022/11/18/dynamic-program/fenzhi.PNG"></p>
<p>其实说“什么问题能用动态规划”并不是很恰当，我们应该这样说“<strong>什么问题适合用动态规划来更轻松的解决？</strong>”</p>
<p>那就是<strong>小问题的答案长期被复用。</strong></p>
<p><strong>复用</strong>，这个熟悉的词汇又出现了，长期被复用，这才是关键。</p>
<p>如果不被长期复用，那么除去“缓存、复用”的步骤，这个“定义”依然是可以适用于其他情况的。</p>
<p>因为从哲学来说，实际上大问题都是可以转化为小问题的。那为什么我们一定要用动态规划呢？我们用递归从上到下暴力求解不也可以吗？还减少了“<strong>找状态转移方程</strong>”这个麻烦的过程，我们直接把数据交给计算机，叫计算机一个一个遍历然后从中筛选取得我们想要的值就行了，要知道计算机最擅长的就是计算，计算机最不怕的就是大量的数据。</p>
<p>一切的一切，在于<strong>长期被复用</strong>。</p>
<p>多次被复用，那么用一个结构<strong>储存</strong>当前的结果，以便于后续使用，这才是对我们，对计算机最善良的做法。</p>
<p>在这里举一个Fibonacci数列的例子，更好的理解长期被复用带来的影响。</p>
<p><img src="/2022/11/18/dynamic-program/fibo.PNG"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fibonacci数列的转移方程是：F(n)=F(n-1)+F(n-2)</span><br><span class="line"></span><br><span class="line">你要求F(100)，自然要知道F(99),F(98)。</span><br><span class="line"></span><br><span class="line">你要求F(99)，自然要知道F(98),F(97).</span><br><span class="line"></span><br><span class="line">你要求F(98)，自然要知道F(97),F(96).</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fibonacci数列在学校基本都是用来讲递归使用的，但是你仔细思考一下，Fibonacci数列用<strong>递归方法</strong>这样轮下去，你会发现你调用了很多很多很多步骤去重复求一个<strong>已经求出来的值</strong>。</p>
<p>所以我们重新思考一下：</p>
<ul>
<li><p>1.Fibonacci数列满足最优子结构吗？答案很明显，Fibonacci数列问题就是一个大问题拆解成小问题，小问题再拆解成小小问题来解决的.</p></li>
<li><p>2.Fibonacci数列满足无后效性吗？答案也是很明显的，Fibonacci数列很明显也只需要用到N-1和N-2的数值即可.</p></li>
</ul>
<p>递归方法，你要从F(99)求到F(1)，然后再从F(98)求到F(1)，你才能得到F（100）</p>
<p>动态规划，我们第一次求到F（99）的时候直接保存值（很明显，每一个值在Fibonacci数列里面都会调用多次），后期用到直接拿来用，省下的时间复杂度是指数级别，不是一点半点。</p>
<h4 id="三.动态规划思路">三.动态规划思路</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.明确题目里的状态</span><br><span class="line"></span><br><span class="line">2.明确DP数组的定义</span><br><span class="line"></span><br><span class="line">3.做出正确的状态转移方程。</span><br></pre></td></tr></table></figure>
<p>在Fibonacci数列问题里面，我们要求的是指定数字的Fibonacci值</p>
<p><strong>状态</strong>自然就是数字n，</p>
<p>我们把F（n）<strong>定义</strong>为：数字为n时的Fibonacci值</p>
<p>那么根据我们的状态定义，该题正确的<strong>状态转移方程</strong>是 F(n)=F(n-1)+F(n-2)</p>
<p>每一次求出F（n），我们就把这个值<strong>保存起来</strong>，实现了<strong>缓存数据</strong>并<strong>复用</strong>。</p>
<p>以上任何一个环节定义错误，都会影响到下一环节的进行，这就要求我们明确状态、明确DP数组的定义，不然转移方程有可能会不再适用（也就是脱离了“最优子结构”或脱离了“无后效性”），也就自然得出了错误的最终结果。</p>
<p>这种情况下，我们要重新考虑状态、重新考虑DP数组的定义。确保DP状态的定义满足：</p>
<ul>
<li>1.最优子结构</li>
<li>2.无后效性</li>
</ul>
<p>通过几个题目，我本人的一般处理思路是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.思考状态是否找对、找全？下一结果不能由当前结果递推得到（也就是说，当前的DP状态定义不满足“最优子结构”），有可能是状态不够，也许这个DP数组可以升为二维、三维甚至更多维来解决（参考 Leetcode.买卖股票问题）、或者可能要用到两个、多个状态定义来做（参考 Leetcode.乘积最大子数组）用到来储存更多状态.</span><br><span class="line"></span><br><span class="line">状态越明确，范围越明确，从而可以从更多的状态（更为明确的范围）里面做出正确的选择，找出正确的状态转移方程。</span><br><span class="line"></span><br><span class="line">2.思考DP数组的定义是否正确？DP[i]储存的东西是什么？变换一下思路，定义正确的DP数组，充分仔细考虑问题条件与所求，确保储存的东西一经确定，不会受到未来（过去）的影响。（参考最长子数组和问题）</span><br></pre></td></tr></table></figure></p>
<p><strong>为什么一定要保证状态的定义满足最优子结构、无后效性？</strong></p>
<p>上面已经写了，DP数组定义不适当的话，不仅找不到合适的状态转移方程，而且在做题过程中可能会混乱状态，不知所然。</p>
<p>拿 <a href="https://leetcode.cn/problems/maximum-subarray/">最长子数组和</a> 的问题来举例.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">子数组 是数组中的一个连续部分。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p>如果你做了一些其他求最值的动态规划的题目，不按步骤一一考虑，按所谓“经验”，胡乱的你可能就这样定义F[i]了：前i个数字里面的最大子数组和，结果输出F[len(nums)-1]就行了。</p>
<p>看起来似乎没毛病，但当你按这个定义时，状态转移方程怎么找？</p>
<p>举个例子，nums = [4,-1,5] 这个数组，当你一开始选了4的时候，max更新为4，由于下一个是-1，4-1=3，比之前的小了，于是你放弃了选择-1，放弃了继续连续，于是你重新开始，选了[3]，max = 5。这就是<strong>鼠目寸光</strong>，如果你继续选，max是可以达到4-1+5=8的。</p>
<p>于是，我们应该这样定义F(n)：以n为右端点的子数组的最大和。</p>
<p>于是，以每一个数字为右端点的子数组和就都有了，然后我们再考虑后面的结果加不加这个值，这样就会避免再出现之前鼠目寸光的情况，最后从所有的F（n）中选出最大值，也就是以n为右端点的子数组的最大值就是最长子数组和的大小。</p>
<p>所以这道题目的状态转移方程为： <span class="math display">\[
F(i) = max(nums[i],nums[i]+F(i-1)) | i\ \le n
\]</span> 关键就在于，这个问题问的是<strong>数组和</strong>。要么<strong>连续</strong>，要么<strong>重新开始、割舍一切</strong>。所以，最大值不一定是F(end）,我们应该从F（1..end)里面寻找<strong>最大值</strong>，即为我们要求的最大子数组和。</p>
<p>该题的Python解法代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">nums = [<span class="number">0</span>]+[-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line">dp=[<span class="number">0</span>]*n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(nums[i],nums[i]+dp[i-<span class="number">1</span>])</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
