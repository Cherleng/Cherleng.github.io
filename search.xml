<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Backtrack 回溯算法</title>
    <url>/2022/07/19/2022-05-14-backtrack/</url>
    <content><![CDATA[<h4 id="引言">1.引言</h4>
<blockquote>
<p>黄色的树林里分出两条路，可惜我不能同时去涉足,我选择了人迹稀少的一条，从此决定了我一生的道路</p>
</blockquote>
<h4 id="什么是回溯算法">2.什么是回溯算法？</h4>
<p>Backtrack算法，中译回溯算法，是一个非常实用的一个算法，如果用一个谚语来形容回溯算法，我愿意称之为“不撞南墙不回头”的一种算法。</p>
<p>为什么这么说呢？因为回溯算法实质上就是一种不断尝试，通过不断的“试错”不断更改信息的一种算法。</p>
<p>“不撞南墙”说明了当回溯算法不遇到错误的时候，“不回头”就是不返回上一步重新尝试。</p>
<p>从引言的那首罗伯特.弗罗斯特的诗里，“可惜我不能同时去涉足”，可是对于回溯算法来说不是这样的，回溯算法看到路走错了就不会继续走了，它会折返到最近的一个分岔口，重新选择一条道路行走。</p>
<figure>
<embed src="https://tse1-mm.cn.bing.net/th/id/R-C.91867e276501f596a4802b67aea756f6?rik=T2H1qdJZGAQe7g&amp;riu=http%3a%2f%2fimg95.699pic.com%2fphoto%2f50123%2f6755.jpg_wh300.jpg!%2ffh%2f300%2fquality%2f90&amp;ehk=6ZJzrS%2bT3A%2fCApII9W0nWQRrSgaCGaU1C3o6wI7aRLs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&amp;sres=1&amp;sresct=1" /><figcaption>分岔的道路</figcaption>
</figure>
<p>回溯算法可以用来解数独，进行排列组合，解决N皇后等问题</p>
<h4 id="回溯算法的实现">3.回溯算法的实现</h4>
<p>让我们来看一看<a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a> 这道题</p>
<p>这道题要求我们从board里面查找某一个单词（例如：ABCDE)，如果查找到单词，我们就返回True，否则返回False。</p>
<figure>
<img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="单词搜索" /><figcaption>单词搜索</figcaption>
</figure>
<p>如上所示，黄色的路径就代表我们成功找到了“ABCDE”这个连续的单词。我们可以从上、下、左、右四个方向进行单词查找。</p>
<p>这里有一点需要注意，单词并不需要第一行第一列的数字来开始，我们可以从任何点上开始单词。</p>
<h5 id="回溯算法的基本思路">回溯算法的基本思路</h5>
<p>1.确定Base case，即考虑一些越界情况，结果实现的情况。</p>
<p>2.在选择列表中进行选择</p>
<p>3.迭代下一个情况</p>
<p>4.撤销选择</p>
<p>这个回溯算法可以如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">x,y,index</span>)</span><br></pre></td></tr></table></figure>
<pre><code>  File &quot;C:\Users\86157\AppData\Local\Temp/ipykernel_7228/2593934997.py&quot;, line 1
    def backtrack(x,y,index)
                            ^
SyntaxError: invalid syntax</code></pre>
<p>x,y就是我们传进去的board的行数和列数，index为单词的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y,index</span>):</span><br><span class="line">            <span class="comment">#base case</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=row <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> y&gt;=col: 、</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[x][y]!=word[index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> index ==<span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#做选择</span></span><br><span class="line"></span><br><span class="line">            board[x][y] = <span class="string">&#x27;#&#x27;</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">#进行迭代</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>]]:</span><br><span class="line">                next_x = x+i[<span class="number">0</span>]</span><br><span class="line">                next_y = y+i[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> dfs(next_x,next_y,index+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">            <span class="comment">#撤销选择</span></span><br><span class="line">            </span><br><span class="line">            board[x][y] = word[index]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">#开始点，可以从任一行任一列开始</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> dfs(i,j,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如上，按照思路，第一步：确立Base case，当索引为index的单词字符刚刚和board的x行y列的字符相同时，继续走下去，如果不是，则return，程序返回上一步（即返回上一次for循环，进行下一个循环），如果继续走下去，就再次执行刚刚的内容，如此循环，直至我们可以找到一个序列和给出的单词一致，即index的长度达到了单词的长度。</p>
<p>让我们来看下一道一个比较简单的题目， <a href="https://leetcode.cn/problems/permutations/">全排列</a></p>
<p>输入：nums = [1,2,3]</p>
<p>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums): <span class="comment">#base case</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                track.append(nums[i]) <span class="comment">#选择</span></span><br><span class="line">                backtrack() <span class="comment">#迭代</span></span><br><span class="line">                track.pop()<span class="comment">#撤销选择</span></span><br><span class="line">                </span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>还是惯常的思路，确立一个Base case,然后进行选择，进行迭代，撤销选择。</p>
<p>其实从回溯算法里面，我们也能发现一件事，那就是所谓“智能”的计算机，实际上是因为计算机拥有巨大的“计算能力&quot;，它能不厌其烦的进行大量的数据处理，并从这些数据中根据我们所确立的“basecase”进行选择。</p>
<p>如果你跟一个不知道计算机怎么运行的人演示这个全排列算法（如果你去演示一个N皇后，解数独的例子可能更好），他们会纠结于为什么你跟电脑说：“给我一个数组[1,2,3]的全排列输出。”电脑就会如实的做到，电脑他难道是因为知道全排列的含义而去思考吗？实际上是你给他一个指令，让他去遍历这些数组组成的所有有用序列，然后返回而已。</p>
<p>不过，这样也可以说明，电脑是可以拥有“学习能力”的，比如你给计算机一百万个数据，让他去处理这之间的关系（而不需要你告诉它关系是什么），然后你再丢给它一个不是数据里数字，他能返回给你一个“最接近结果”的一个值，当然，这就是另一种事情了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-SVD分解算法的物理意义</title>
    <url>/2022/07/19/svd%20linear/</url>
    <content><![CDATA[<p>奇异值分解（Singular Value Decomposition），以下简称SVD。</p>
<p>奇异值分解算法是一种在机器学习中经常使用到的一个算法，SVD主要用于数据压缩和数据降维，在图像压缩、推荐系统有着极其重要的作用，</p>
<p>本文将着重理解SVD分解算法的物理意义以及我们将用Python代码将这个过程可视化，数学推导将不是本文的重点，将在它文展示。</p>
<h4 id="一.svd分解介绍">一.SVD分解介绍</h4>
<p>任何一个形状的矩阵（图像）都可以转化从先旋转、再延伸、再旋转的形式。</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-e6b7d1aa8b6e302c1973d44d45d7f540_720w.jpg" alt="svd1" /><figcaption>svd1</figcaption>
</figure>
<h4 id="公式如下">公式如下</h4>
<figure>
<img src="https://pic3.zhimg.com/80/v2-a71a3b4be58eaea23992595d495c55ce_720w.jpg" alt="svd2" /><figcaption>svd2</figcaption>
</figure>
<p>SVD分解就是将一个矩阵转变为这三个矩阵的表达形式，同时，这三个矩阵分别代表一个旋转、一个伸缩、一个旋转。</p>
<figure>
<img src="https://pic2.zhimg.com/80/v2-afcc2be24efd8e722cbcf14aef0aff1d_720w.jpg" alt="img" /><figcaption>img</figcaption>
</figure>
<h4 id="为什么呢">为什么呢？</h4>
<p>提出问题就解决了一半的问题。为什么一个矩阵可以转变为一个旋转矩阵、一个伸缩矩阵、一个旋转矩阵相乘呢？</p>
<p>让我们来看一个简单的例子</p>
<p><img src="https://s1.328888.xyz/2022/05/15/qmgP7.png" alt="img1" /> <img src="https://s1.328888.xyz/2022/05/15/qmGKM.png" alt="img2" /></p>
<p>Unit circle 要怎么转换才能转换成为下图中的A的形式呢？（这里要注意点的颜色！）</p>
<p>首先，我们先让Unit circle逆时针旋转135度。</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmyl2.png" alt="img3" /><figcaption>img3</figcaption>
</figure>
<p>再让旋转后的图像在x轴上伸长6.70820393249937倍（为什么是这个倍数，先不用纠结，这是奇异值分解以后的一个奇异值数），在y轴上伸长2.2360679774997894倍</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmJhX.png" alt="img4" /><figcaption>img4</figcaption>
</figure>
<p>然后我们再让图像旋转一次，即可得到和A同等的一个图像. U sigma Vt</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmLYZ.png" alt="img10" /><figcaption>img10</figcaption>
</figure>
<p>这样，原图到A的过程就可以转变为将原图先进行一个旋转、再进行一个伸缩、再进行一个旋转。</p>
<p>我们知道，任何的图像的变化都可以用线性代数里的一个矩阵来表示。</p>
<p>实际上，从原图到A的一个变换矩阵就是</p>
<p><span class="math display">\[
A =  \left|\begin{matrix}
    3 &amp; 0  \\
    4 &amp; 5 
   \end{matrix} \right|
 \]</span></p>
<p>我们将其拆解以后，第一个转换图像对应的旋转是逆时针旋转135度，我们可以将第一个旋转用矩阵表示为</p>
<p><span class="math display">\[
  V=\left|\begin{matrix}
    -0.71 &amp; -0.71  \\
    -0.71 &amp; 0.71 
   \end{matrix} \right|
 \]</span></p>
<p>然后进行左乘一个伸缩矩阵（注意里面的数字和上面那个伸缩大小之间）</p>
<p><span class="math display">\[
  \Sigma = \left|\begin{matrix}
    6.71 &amp; 0  \\
    0 &amp; 2.24 
   \end{matrix} \right|
 \]</span></p>
<p>然后最后再左乘一个旋转矩阵</p>
<p><span class="math display">\[
  U = \left|\begin{matrix}
    -0.32 &amp; -0.95  \\
    -0.95 &amp; 0.32 
   \end{matrix} \right|
 \]</span></p>
<p>我们用Python中的Nupmy来协助我们计算一下这三个矩阵相乘后是否等于A</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">V =np.array( [[-<span class="number">0.71</span> ,-<span class="number">0.71</span>],</span><br><span class="line"> [-<span class="number">0.71</span> , <span class="number">0.71</span>]])</span><br><span class="line"></span><br><span class="line">sigma = np.array([[<span class="number">6.71</span> ,<span class="number">0.</span>  ],</span><br><span class="line"> [<span class="number">0.</span>  , <span class="number">2.24</span>]])</span><br><span class="line"></span><br><span class="line">U = np.array([[-<span class="number">0.32</span> ,-<span class="number">0.95</span>],</span><br><span class="line"> [-<span class="number">0.95</span>  ,<span class="number">0.32</span>]])</span><br><span class="line"></span><br><span class="line">res1 = np.matmul(U, sigma)</span><br><span class="line">res1</span><br><span class="line">res2 = np.matmul(res1,V)</span><br><span class="line">res2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>array([[3.035392, 0.013632],
       [4.016967, 5.034823]])</code></pre>
<p>我们看到矩阵相乘后生成了一个新的矩阵，而这个矩阵正是和A矩阵极其相近的一个矩阵（计算机已经认为一致）</p>
<p><span class="math display">\[
  res2 = \left|\begin{matrix}
    3.035392 &amp; 0.013632  \\
    4.016967 &amp; 5.034823 
   \end{matrix} \right|
 \]</span></p>
<p><span class="math display">\[
 A =  \left|\begin{matrix}
    3 &amp; 0  \\
    4 &amp; 5 
   \end{matrix} \right|
 \]</span></p>
<p>现在我们已经可以将一个复杂的变化（或者称之为一个复杂的变化<strong><em>矩阵</em></strong>）转变为三个简易的变化（或者称之为三个简易的变化<strong><em>矩阵</em></strong>）相乘（一个旋转、一个伸缩、一个旋转），然而事实上，<strong><em>任何一个复杂的变化都可以转变为这种分解的形式</em></strong>（在这里我们用二维矩阵来表示，为的是得到一个可视化的变化）我们称之为<strong><em>SVD奇异值分解</em></strong>。</p>
<figure>
<img src="https://pic3.zhimg.com/v2-ecca2d8bad88b73764f9af8def24c158_1440w.jpg?source=172ae18b" alt="img7" /><figcaption>img7</figcaption>
</figure>
<p>你也看到了，<span class="math inline">\(\Sigma\)</span>是一个特殊的对角矩阵，而且通过刚刚可视化的转化，你知道<span class="math inline">\(\Sigma\)</span>内对角线上面的数字代表了对矩阵的变化大小程度（对拉伸变化的大小程度）也就是说<span class="math inline">\(\Sigma\)</span>内对角元素更像是代表了一种权重，比如我们将x轴拉伸为原来的6.71倍，这个变化看起来相较于将y轴变为原来的2.24倍大一点，说明我们在x轴上面进行的操作特征更接近于与原矩阵进行的操作，实际上<span class="math inline">\(\Sigma\)</span>内对角线的元素从大到小排列，我们通常只需要取出前面的几个特征值就能很好的将原图像的图像表示出来，这同时也与图像压缩相关，因为计算机内的图像实际上是数以百万计的矩阵像素形式。</p>
<figure>
<img src="https://pic3.zhimg.com/80/v2-4437f7678e8479bbc37fd965839259d2_720w.jpg" alt="img8" /><figcaption>img8</figcaption>
</figure>
<p>由于<span class="math inline">\(\Sigma\)</span>是一个对角矩阵，即对角线上面存在元素，而其他位置的元素为0，根据矩阵相乘的原理，我们可以将<span class="math inline">\(\Sigma\)</span>内的对角元素提取出来，这个公式就转换成了</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-90a904448099ee0f3158bfa045012bb8_720w.jpg" alt="img5" /><figcaption>img5</figcaption>
</figure>
<p>其中<span class="math inline">\(\sigma1\)</span>代表<span class="math inline">\(\Sigma\)</span>中的第一个对角元素，u1代表U矩阵中的第一行，v1转置代表V矩阵中的第一列</p>
<p>刚刚那个矩阵由于奇异值都相差不是很大，所以说“<span class="math inline">\(\Sigma\)</span>内的对角元素更多代表一种和原图像相似的一个权重”展示的可能不是那么明显。</p>
<p>如果我们将x轴延申80倍，然后y轴转换为原图的2倍看一看</p>
<p>图像就变为了这样的：</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmXMC.png" alt="img11" /><figcaption>img11</figcaption>
</figure>
<p>最终的结果：</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmifg.png" alt="img11" /><figcaption>img11</figcaption>
</figure>
<p>该图像对应原图的的变换矩阵为：</p>
<p><span class="math display">\[
 A =  \left|\begin{matrix}
    19.23018461 &amp; 16.54690303  \\
    53.21841786 &amp; 54.11284506
   \end{matrix} \right|
 \]</span></p>
<p>这样看来，似乎对y轴的操作看起来微乎其微，因为这些不同颜色的点已经几近贴合为一条线，那如果我们直接舍去对y轴的操作，</p>
<p>图像变为了这样：</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qmrp1.png" alt="img11" /><figcaption>img11</figcaption>
</figure>
<p>我们来看看该图像对应的变换矩阵为：</p>
<p><span class="math display">\[
 \sigma1\mu1v1=B =  \left|\begin{matrix}
    17.88854382 &amp; 17.88854382  \\
    53.66563146 &amp; 53.66563146 
   \end{matrix} \right|
 \]</span></p>
<p>B和A极其相似！</p>
<p>也就是说我们现在只保留最大的那个特征值，相乘后的结果与原图差别并不是很大，即<strong><em>该矩阵结果与原来的矩阵相差不是很大</em></strong>，很好的拟合了原矩阵的图像。</p>
<p>但我们依然来看看如果将第一个特征值抹去为0，只保留第二个奇异值来计算矩阵的大小C为多少？，由于矩阵相乘原理，其他地方置为0，保留第二个奇异值计算相当于将第二个奇异值乘以V的第二行然后乘以U的第二列。</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qaoh2.png" alt="qaoh2.png" /><figcaption>qaoh2.png</figcaption>
</figure>
<p>在100x100的视窗里面，它似乎成了一个点，而且没有怎么动，与U sigma Vt的图像从视觉上看相差很大，而且C的结果也很小，与A矩阵相差很大（在这里C实际上就是A-B的结果）</p>
<p><span class="math display">\[
 \sigma2\mu2v2=C =  \left|\begin{matrix}
    1.34164079 &amp; -1.34164079  \\
    -0.4472136 &amp; 0.4472136
   \end{matrix} \right|
 \]</span></p>
<p>所以，现在你应该能够更能理解奇异值的大小更多的代表一种相似权重这个意思吧。SVD分解将<span class="math inline">\(\Sigma\)</span>的“头部”集中了更多的“<strong><em>质量</em></strong>”，忽略远离“头部”的奇异值对恢复矩阵的影响越小,也就是说我们在上面这个例子里面，只拿出第一个<span class="math inline">\(\Sigma\)</span>的值就能很好的相似拟合出原来A的矩阵，而可以舍去其他奇异值，因为它们对整个矩阵A的拟合影响不是很大，无论是从这个二维画图来看，还是从矩阵内的的数字大小来看都可以看出来。</p>
<h4 id="如何用python中的numpy计算svd">如何用Python中的Numpy计算SVD？</h4>
<p>Python中有一个Numpy库中，已经给我们内置了一个函数svd(matrix)可以直接求出一个矩阵的SVD分解后的U、<span class="math inline">\(\Sigma\)</span>、V</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> svd</span><br><span class="line">P = np.array([[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>]])</span><br><span class="line">U,S,V=svd(P)</span><br><span class="line">U</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.21472623,  0.37397651, -0.13150279, -0.89260362],
       [-0.5186023 , -0.70137666,  0.43020321, -0.23248147],
       [-0.48143993, -0.20822528, -0.83770916,  0.15199076],
       [-0.67317152,  0.56996016,  0.30963782,  0.35511962]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>
<pre><code>array([21.23135684,  6.43244475,  4.88175527,  0.14699287])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">V</span><br></pre></td></tr></table></figure>
<pre><code>array([[-0.55120987, -0.51992284, -0.48804478, -0.43319766],
       [ 0.26483885, -0.40006067,  0.65008996, -0.58923246],
       [ 0.07265877,  0.69537763, -0.21865293, -0.68070665],
       [ 0.78787611, -0.29339674, -0.53980203, -0.04222983]])</code></pre>
<p>可以看到，在使用Numpy进行SVD计算时，对角矩阵<span class="math inline">\(\Sigma\)</span>转化为了一个向量形式S的表达形式，如果要转化为矩阵形式，可以使用np.diag(S)函数进行转化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sigma1 = np.diag(S)</span><br><span class="line">sigma1</span><br></pre></td></tr></table></figure>
<pre><code>array([[21.23135684,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  6.43244475,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  4.88175527,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.14699287]])</code></pre>
<h4 id="奇异值包含了矩阵的本质信息">奇异值包含了矩阵的“本质信息”</h4>
<p>仔细看一看B矩阵，你能发现什么？</p>
<p><span class="math display">\[
 B =  \left|\begin{matrix}
    17.88854382 &amp; 17.88854382  \\
    53.66563146 &amp; 53.66563146 
   \end{matrix} \right|
 \]</span></p>
<p>没错，B是一个Rank为1的矩阵，实际上，当我们将每一项奇异值取出相乘再相加时，我们就是将多个Rank为1的矩阵相加</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-90a904448099ee0f3158bfa045012bb8_720w.jpg" alt="img5" /><figcaption>img5</figcaption>
</figure>
<p>为什么说奇异值包含了矩阵的“本质信息”呢？</p>
<p>你看，如果一个矩阵“足够奇异”，那么我就只需要取出前几项奇异值对应的rank为1的矩阵相加就能很好的拟合出原矩阵，奇异值能够剖析矩阵的本质，深析这个原矩阵是个多少Rank的一个矩阵，也就是说矩阵越“奇异”，其行（或列）向量彼此越线性相关，越能彼此互相解释。即奇异值包含了矩阵的“本质信息”</p>
<p>这里也能间接告诉我们一个信息，那就是<span class="math inline">\(\Sigma\)</span> 内有多少个奇异值，原来的矩阵就是Rank为几的一个矩阵。</p>
<h4 id="在图像压缩上面的应用">在图像压缩上面的应用</h4>
<p>我们将尝试将这个爱心进行图像压缩</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qklNW.png" alt="qklNW.png" /><figcaption>qklNW.png</figcaption>
</figure>
<p>这里需要提一下的是，我们都知道在电脑中一个图像就是由许多像素点组成的一个矩阵，所以上图的矩阵我们可以表达为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             ])</span><br></pre></td></tr></table></figure>
<p>0代表白色区域，1代表黑色区域</p>
<p>我们先利用Numpy中的svd函数将矩阵D的U,S,V值求出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">U,S,V=svd(D)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(U,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">sigma = np.diag(S)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(sigma,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(V,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[-0.36  0.   -0.73 -0.05  0.33  0.48]
 [-0.54 -0.35  0.27 -0.08 -0.58  0.4 ]
 [-0.54 -0.35  0.27 -0.08  0.58 -0.4 ]
 [-0.45  0.35 -0.27  0.52 -0.33 -0.48]
 [-0.28  0.71  0.18 -0.62 -0.   -0.  ]
 [-0.08  0.35  0.46  0.57  0.33  0.48]]

[[4.74 0.   0.   0.   0.   0.  ]
 [0.   1.41 0.   0.   0.   0.  ]
 [0.   0.   1.41 0.   0.   0.  ]
 [0.   0.   0.   0.73 0.   0.  ]
 [0.   0.   0.   0.   0.   0.  ]
 [0.   0.   0.   0.   0.   0.  ]]

[[-0.23 -0.4  -0.46 -0.4  -0.46 -0.4  -0.23]
 [-0.5  -0.25  0.25  0.5   0.25 -0.25 -0.5 ]
 [ 0.39 -0.32 -0.19  0.65 -0.19 -0.32  0.39]
 [-0.22  0.42 -0.44  0.42 -0.44  0.42 -0.22]
 [ 0.55 -0.44  0.09  0.   -0.09  0.44 -0.55]
 [-0.4  -0.55 -0.2  -0.    0.2   0.55  0.4 ]
 [ 0.2   0.1  -0.67  0.    0.67 -0.1  -0.2 ]]</code></pre>
<p>我们将<span class="math inline">\(\Sigma\)</span>中的第一个值4.74取出，计算这个rank1的矩阵</p>
<p><span class="math display">\[\sigma1\mu1v1\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">0</span>]*np.outer(U[:,<span class="number">0</span>],V[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[0.39 0.68 0.78 0.68 0.78 0.68 0.39]
 [0.59 1.02 1.17 1.02 1.17 1.02 0.59]
 [0.59 1.02 1.17 1.02 1.17 1.02 0.59]
 [0.48 0.84 0.97 0.84 0.97 0.84 0.48]
 [0.3  0.52 0.6  0.52 0.6  0.52 0.3 ]
 [0.09 0.16 0.18 0.16 0.18 0.16 0.09]]</code></pre>
<p>取第二个奇异值1.41，计算出<span class="math display">\[\sigma2\mu2v2\]</span>，取第三个奇异值1.41，计算出<span class="math display">\[\sigma3\mu3v3\]</span>....我们看到奇异值非0数只有4个，说明原矩阵是一个rank为4的矩阵，当我们取到第四个奇异值<span class="math display">\[\sigma4\mu4v4\]</span>将再将这些所有的秩一矩阵相加即可还原原矩阵D的图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">1</span>]*np.outer(U[:,<span class="number">1</span>],V[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[-0.   -0.    0.    0.    0.   -0.   -0.  ]
 [ 0.25  0.13 -0.13 -0.25 -0.13  0.13  0.25]
 [ 0.25  0.13 -0.13 -0.25 -0.13  0.13  0.25]
 [-0.25 -0.13  0.13  0.25  0.13 -0.13 -0.25]
 [-0.5  -0.25  0.25  0.5   0.25 -0.25 -0.5 ]
 [-0.25 -0.12  0.13  0.25  0.13 -0.12 -0.25]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">2</span>]*np.outer(U[:,<span class="number">2</span>],V[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[-0.4   0.33  0.2  -0.67  0.2   0.33 -0.4 ]
 [ 0.15 -0.12 -0.07  0.25 -0.07 -0.12  0.15]
 [ 0.15 -0.12 -0.07  0.25 -0.07 -0.12  0.15]
 [-0.15  0.12  0.07 -0.25  0.07  0.12 -0.15]
 [ 0.1  -0.08 -0.05  0.17 -0.05 -0.08  0.1 ]
 [ 0.25 -0.21 -0.12  0.42 -0.12 -0.21  0.25]]</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">3</span>]*np.outer(U[:,<span class="number">3</span>],V[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0.01 -0.02  0.02 -0.02  0.02 -0.02  0.01]
 [ 0.01 -0.02  0.03 -0.02  0.03 -0.02  0.01]
 [ 0.01 -0.02  0.03 -0.02  0.03 -0.02  0.01]
 [-0.08  0.16 -0.17  0.16 -0.17  0.16 -0.08]
 [ 0.1  -0.19  0.2  -0.19  0.2  -0.19  0.1 ]
 [-0.09  0.17 -0.18  0.17 -0.18  0.17 -0.09]]</code></pre>
<p>我们看到，在<span class="math display">\[\sigma4\mu4v4\]</span>时，这个矩阵内的数字大小已经很小，几近为0了。</p>
<p>在算<span class="math display">\[\sigma5\mu5v5\]</span>时，由于奇异值<span class="math inline">\(\sigma5\)</span>以及为0，所以该<span class="math display">\[\sigma5\mu5v5\]</span>以及为一个零矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = S[<span class="number">4</span>]*np.outer(U[:,<span class="number">4</span>],V[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(t,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0. -0.  0.  0. -0.  0. -0.]
 [-0.  0. -0. -0.  0. -0.  0.]
 [ 0. -0.  0.  0. -0.  0. -0.]
 [-0.  0. -0. -0.  0. -0.  0.]
 [-0.  0. -0. -0.  0. -0.  0.]
 [ 0. -0.  0.  0. -0.  0. -0.]]</code></pre>
<p>我们计算可以得出 <span class="math display">\[
 result = D =\sigma\mu1v1+\sigma2\mu2v2+\sigma3\mu3v3+\sigma4\mu4v4\]</span></p>
<p>我们来看看<span class="math display">\[\sigma x\mu xvx\]</span></p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qkoki.png" alt="qkoki.png" /><figcaption>qkoki.png</figcaption>
</figure>
<p>将每一个秩1矩阵相加起来的图像</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qnQSF.png" alt="qnQSF.png" /><figcaption>qnQSF.png</figcaption>
</figure>
<p>可以清晰看到，加到第四个矩阵时，我们就已经得到与原图像（原矩阵）一模一样的图像（矩阵）</p>
<p>这个图像比较小，8x8图像，该图像可能无法让你感觉到奇异值的重要性。</p>
<p>但如果说我们的矩阵是一个1000x1000的图像（一般电脑的图片比这个还要大），如果我们要记录这个图片，我们原本需要电脑记录1000x1000=1000000个像素！也就说一张照片我们需要存入一百万个值。</p>
<p>但如果我们用到了SVD分解，将图片转化为4个秩1的矩阵相加的情况，我们只需要保留2000x4=8000个像素就能完全呈现一个一模一样的原图。</p>
<p>如果我们准备将图片压缩，我们可以舍去后两个秩1矩阵，因为我们之前已经说了<span class="math inline">\(\Sigma\)</span>头部的值往往代表了这个图片的“本质信息”，那就只需要保留2000x2=4000个像素数据就能差不多拟合出原图的照片。</p>
<p>但往往很多时候我们交给计算机处理视觉问题时并不需要一个清晰度极其高的一张图片，这和人类的视觉系统类似。</p>
<p>比如给你这样一张图片</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/15/qn9WQ.jpg" alt="qn9WQ.jpg" /><figcaption>qn9WQ.jpg</figcaption>
</figure>
<p>(希望没有吓到你)</p>
<p>虽然很模糊，但你还是知道它是一只狗。</p>
<p>所以让计算机去处理这些视觉问题时，我们往往只要勾勒出原图的一个模糊图像，能够近似拟合原图的一个图像就行了，这就与SVD分解息息相关。</p>
<p>当然，SVD的应用远不止如此，SVD在图像恢复、PCA、异常检测、图像去噪、推荐系统、SLAM都有着巨大的作用。</p>
<p>感兴趣的话可以去搜一搜，关于SVD分解的数学讲解将放在下一章。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>安装mayavi遇到的一些问题</title>
    <url>/2022/07/19/mayavi/</url>
    <content><![CDATA[<p>mayavi库相较于matplot能够更好的展现3D的视图，最近在学习python的时候要用到mayavi这个库，由于我本人用的是anaconda版本的python，默认python版本是3.8.8版本的，下了mayavi却一直报错，后来去查了查应该是python版本问题，于是搞了个3.7版本的虚拟环境，直接在anaconda下载mayavi仍然一直报错，后来尝试了直接在cmd上pip install等等方法都不可行，搞了一晚上还没搞清楚。</p>
<p>这个过程我也遇到了很多网上相似的问题，但是解决方案回答在互联网上好像很少，我把我的解决流程发上来，供各位参考。</p>
<p>后来干脆手动安装whl的包</p>
<p>安装地址：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">pythonlibs</a></p>
<p>下载内容：mayavi，PyQt4，traits，VTK</p>
<p>这里需要注意的是下载的包必须是匹配的。</p>
<p>避免失误的话，这里你可以参考我的下载的包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mayavi-<span class="number">4.7</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">PyQt4-<span class="number">4.11</span><span class="number">.4</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">traits-<span class="number">6.3</span><span class="number">.1</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">VTK-<span class="number">9.0</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<p>安装mayavi并不难，关键是mayavi所依赖的环境复杂，前期我下载的时候是胡乱安装的，导致我运行程序的时候一直报错。</p>
<p>将下载的四个文件的文件夹通过3.7的虚拟环境打开，然后直接输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mayavi-<span class="number">4.7</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">pip install PyQt4-<span class="number">4.11</span><span class="number">.4</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">pip install traits-<span class="number">6.3</span><span class="number">.1</span>-cp37-cp37m-win_amd64.whl</span><br><span class="line">pip install VTK-<span class="number">9.0</span><span class="number">.3</span>-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>以上的解决方案在互联网上已经有了，下面是一些我遇到的问题。</p>
<h4 id="报错attributeerror-type-object-dialogcode-has-no-attribute-accepted解决方案">报错AttributeError: type object 'DialogCode' has no attribute 'Accepted'解决方案</h4>
<p>在命令端下载PyQt5以及PyQt5配套的tools库即可。</p>
<figure>
<img src="https://s1.328888.xyz/2022/05/20/DoAiQ.png" alt="DoAiQ.png" /><figcaption>DoAiQ.png</figcaption>
</figure>
<p>然后将pyqt5_tools文件的地址添加到path变量里面即可。</p>
<h4 id="vtk版本不匹配解决方案">VTK版本不匹配解决方案</h4>
<p>WARNING: Imported VTK version (9.1) does not match the one used</p>
<p>to build the TVTK classes (9.0). This may cause problems.</p>
<p>Please rebuild TVTK.</p>
<p>解决办法：将现版本的VTK（9.1)uninstall，然后install 9.0版本的VTK</p>
<p>直接在命令端输入</p>
<p>pip uninstall VTK==9.1</p>
<p>待完成以后再输入</p>
<p>pip install VTK==9.0</p>
<h4 id="检测mayavi.mlab是否正常运行">检测mayavi.mlab是否正常运行</h4>
<p>在ipython中输入：</p>
<p>from mayavi import mlab</p>
<p>如果不报错即成功解决问题</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记 1 - 什么是Git？</title>
    <url>/2022/07/21/git1-1/</url>
    <content><![CDATA[<hr />
<h3 id="一.什么是git">一.什么是Git？</h3>
<p>作为一名开发人员，在日常开发中，我们能经常见到Git这个字眼，那么Git到底是什么？为什么那么重要？在开发过程中为什么需要用到它？在我们开始学习Git之前，这些东西是我们需要知道的。接下来的文字也许能让你进一步理解Git的它的历史演变以及它的重要性。</p>
<p>Git是一个<strong>分布式版本控制系统</strong>。</p>
<p>什么是版本控制系统？一个很简单的例子，在你编辑文档的时候，因为某些失误，你把一个很重要的信息给删掉了，你并不着急，因为你此时可以选择撤销按钮，将之前误删的信息给还原。</p>
<p><img src="https://is1-ssl.mzstatic.com/image/thumb/Purple114/v4/26/5d/8d/265d8db0-5081-2d57-482f-d3baa615f536/AppIcon-0-1x_U007emarketing-0-7-0-sRGB-0-0-0-85-220-0.png/1200x630wa.png" /></p>
<p>其实可以这样理解，你的每一个操作，对于文档来说就是一个独立的“版本”。</p>
<p>现在很多信息的填写，都用到了“共享文档”这个体系，其实就是避免了多方对信息的处理不一致导致的冲突，我在编辑文档的同时也能看得见你的编辑。但放在多年前，如果一个文档你需要别人对其进行一些增删改查，而你在别人帮你修改的同时自己也将文档增添润色了一下，等到别人把已经改正的文档发给你时，你怎么知道他改了哪些地方，哪些地方和你润色后的版本有了冲突呢？</p>
<p>而分布式，就是<strong>非集中式</strong>（对，这是句废话）</p>
<p>以往的集中式，特别繁琐，需要有一个中央服务器，如果要进行修改，要先得到中央服务器的服务版本，然后修改以后再推给中央服务器，是一种自上而下的版本管理方式。像SVN，CVS 等这些版本管理系统就是集中式的。</p>
<p>而分布式，不需要进行联网可以进行修改操作（工作区），然后再提交给其他服务器（电脑），这时候不需要一个中央服务器的存在，而是每一个独立的电脑就是一个独立的服务器。</p>
<p>这时候就要Git登场了。</p>
<h4 id="git的诞生">1.Git的诞生</h4>
<p>Linus 建立了开源 Linux以后，依然要管理从世界各地志愿者为 Linux编写的代码，全世界那么多代码，初期Linus确实是靠自己个人管理的，后来Linux越来越壮大，代码量如此之大，是时候选一个<strong>版本控制系统</strong>来管理这些代码了，之前为什么不选择使用CVS、SVN这些<strong>集中式</strong>版本控制系统，原因是因为这些系统不仅速度慢，而且必须通过联网才能使用。其他的商用控制系统Linus不选，因为与Linux开源精神极其不符。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上.（1991－2002年间）</p>
<p>这时候BitKeeper愿意免费为Linux社区提供免费的版本控制服务，但作为具有巨大开源精神的Linux社区志愿者们多次尝试破解BitKeeper的协议...</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使Linus Torvalds重新思考如何管理这些世界各地的代码。</p>
<p>两周后，分布式控制系统Git在Linus的家中诞生。</p>
<p><img src="https://imgix.gizmodo.com.au/content/uploads/sites/2/2018/01/linusfinger.jpg?ar=16:9&amp;auto=format&amp;fit=crop&amp;q=65&amp;w=1280" /></p>
<h3 id="二.git的安装">二.Git的安装</h3>
<p>访问<a href="https://git-scm.com/downloads">Git官网</a> 下载对应的系统版本，由于我本人使用的是Windows版本，故下载Git for windows版本。</p>
<hr />
<hr />
<p>本笔记参考了以下教材：</p>
<p>1.<a href="https://git-scm.com/">Git官方文档</a></p>
<p>2.<a href="https://www.liaoxuefeng.com/">廖雪峰Git博客教程</a></p>
<hr />
]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
